<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BSM Hypergraph Discovery</title>
  <style>
/* BSM Hypergraph Discovery — Dark Theme */

:root {
  --bg-primary: #0d1117;
  --bg-secondary: #161b22;
  --bg-tertiary: #21262d;
  --border-color: #30363d;
  --text-primary: #e6edf3;
  --text-secondary: #8b949e;
  --text-muted: #6e7681;
  --accent-blue: #4fc3f7;
  --accent-orange: #ffb74d;
  --accent-green: #81c784;
  --accent-purple: #ce93d8;
  --accent-red: #ff8a80;
  --sidebar-width: 300px;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  overflow: hidden;
  height: 100vh;
}

/* Layout */
.app-layout {
  display: flex;
  height: 100vh;
}

/* Sidebar */
.sidebar {
  width: var(--sidebar-width);
  min-width: var(--sidebar-width);
  background: var(--bg-secondary);
  border-right: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
}

.sidebar-header {
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
}

.sidebar-header h1 {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.3px;
  color: var(--text-primary);
}

.sidebar-header .subtitle {
  font-size: 11px;
  color: var(--text-secondary);
  margin-top: 4px;
}

.sidebar-section {
  padding: 14px 16px;
  border-bottom: 1px solid var(--border-color);
}

.sidebar-section h3 {
  font-size: 10px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.8px;
  color: var(--text-muted);
  margin-bottom: 10px;
}

/* Query Parameters */
.query-params {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.query-param-row {
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.query-param-row label {
  font-size: 10px;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  color: var(--text-muted);
  letter-spacing: 0.3px;
}

.query-input {
  width: 100%;
  padding: 6px 8px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 5px;
  color: var(--text-primary);
  font-size: 12px;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  outline: none;
  transition: border-color 0.2s;
  box-sizing: border-box;
}

.query-input:focus {
  border-color: var(--accent-blue);
}

.query-input[type="date"]::-webkit-calendar-picker-indicator {
  filter: invert(0.7);
  cursor: pointer;
}

.query-apply-btn {
  margin-top: 4px;
  padding: 7px 0;
  background: var(--accent-blue);
  color: #fff;
  border: none;
  border-radius: 5px;
  font-size: 11px;
  font-weight: 600;
  cursor: pointer;
  transition: background 0.2s, opacity 0.2s;
}

.query-apply-btn:hover {
  opacity: 0.85;
}

.query-apply-btn:active {
  opacity: 0.7;
}

.query-encoded {
  font-size: 9px;
  font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
  color: var(--text-muted);
  word-break: break-all;
  line-height: 1.5;
  padding: 6px 8px;
  background: var(--bg-primary);
  border-radius: 4px;
  border: 1px solid var(--border-color);
  display: none;
}

.query-encoded.visible {
  display: block;
}

/* Stats Panel */
.stats-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.stat-card {
  background: var(--bg-tertiary);
  border-radius: 6px;
  padding: 10px;
}

.stat-card .stat-value {
  font-size: 20px;
  font-weight: 700;
  color: var(--text-primary);
}

.stat-card .stat-label {
  font-size: 10px;
  color: var(--text-secondary);
  margin-top: 2px;
}

.stat-card.wide {
  grid-column: span 2;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 0;
}

.stat-row .stat-label {
  font-size: 11px;
  color: var(--text-secondary);
}

.stat-row .stat-value {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
}

/* View Toggle */
.view-toggle {
  display: flex;
  gap: 4px;
  background: var(--bg-primary);
  border-radius: 8px;
  padding: 3px;
}

.view-toggle button {
  flex: 1;
  padding: 8px 8px;
  border: none;
  border-radius: 6px;
  background: transparent;
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.view-toggle button.active {
  background: var(--bg-tertiary);
  color: var(--text-primary);
  box-shadow: 0 1px 3px rgba(0,0,0,0.3);
}

.view-toggle button:hover:not(.active) {
  color: var(--text-primary);
}

/* Search */
.search-input {
  width: 100%;
  padding: 8px 10px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: var(--text-primary);
  font-size: 12px;
  outline: none;
  transition: border-color 0.2s;
}

.search-input:focus {
  border-color: var(--accent-blue);
}

.search-input::placeholder {
  color: var(--text-muted);
}

/* Legend */
.legend-list {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  padding: 4px 6px;
  border-radius: 4px;
  transition: background 0.15s;
  user-select: none;
}

.legend-item:hover {
  background: var(--bg-tertiary);
}

.legend-item.hidden {
  opacity: 0.35;
}

.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}

.legend-label {
  font-size: 12px;
  color: var(--text-secondary);
}

.legend-count {
  margin-left: auto;
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 600;
}

/* Sliders */
.control-group {
  margin-bottom: 10px;
}

.control-group:last-child {
  margin-bottom: 0;
}

.control-label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.control-label span {
  font-size: 11px;
  color: var(--text-secondary);
}

.control-label .control-value {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-primary);
}

input[type="range"] {
  -webkit-appearance: none;
  width: 100%;
  height: 4px;
  background: var(--bg-primary);
  border-radius: 2px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: var(--accent-blue);
  cursor: pointer;
}

/* Node Detail Panel */
.node-detail {
  display: none;
}

.node-detail.visible {
  display: block;
}

.node-detail-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.node-detail-name {
  font-size: 13px;
  font-weight: 600;
  color: var(--text-primary);
}

.node-detail-close {
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 16px;
  cursor: pointer;
  padding: 2px 6px;
  border-radius: 4px;
}

.node-detail-close:hover {
  color: var(--text-primary);
  background: var(--bg-tertiary);
}

.node-detail-row {
  display: flex;
  justify-content: space-between;
  padding: 3px 0;
  font-size: 11px;
}

.node-detail-row .detail-key {
  color: var(--text-muted);
}

.node-detail-row .detail-val {
  color: var(--text-secondary);
  font-weight: 500;
}

.node-detail-badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 10px;
  font-size: 10px;
  font-weight: 600;
  margin-bottom: 8px;
}

.node-detail-badge.ci      { background: rgba(79,195,247,0.15); color: var(--accent-blue); }
.node-detail-badge.group   { background: rgba(255,183,77,0.15); color: var(--accent-orange); }
.node-detail-badge.service { background: rgba(129,199,132,0.15); color: var(--accent-green); }
.node-detail-badge.change  { background: rgba(206,147,216,0.15); color: var(--accent-purple); }

/* Co-occurrence Panel */
.cooccurrence-table {
  width: 100%;
  border-collapse: collapse;
}

.cooccurrence-table th {
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  color: var(--text-muted);
  text-align: left;
  padding: 4px 4px 6px;
  border-bottom: 1px solid var(--border-color);
}

.cooccurrence-table th:last-child {
  text-align: right;
}

.cooccurrence-row {
  cursor: pointer;
  transition: background 0.12s;
}

.cooccurrence-row:hover {
  background: var(--bg-tertiary);
}

.cooccurrence-row.active {
  background: rgba(79, 195, 247, 0.08);
}

.cooccurrence-row td {
  padding: 5px 4px;
  font-size: 11px;
  color: var(--text-secondary);
  border-bottom: 1px solid rgba(48, 54, 61, 0.5);
  vertical-align: middle;
}

.cooccurrence-pair {
  display: flex;
  flex-direction: column;
  gap: 1px;
}

.cooccurrence-pair .pair-name {
  color: var(--text-primary);
  font-weight: 500;
  font-size: 10px;
  word-break: break-word;
}

.cooccurrence-count {
  text-align: right;
  font-weight: 700;
  font-size: 13px;
  color: var(--accent-blue);
  min-width: 28px;
}

.cooccurrence-bar-cell {
  width: 60px;
}

.cooccurrence-bar {
  height: 6px;
  border-radius: 3px;
  background: var(--accent-blue);
  opacity: 0.5;
  transition: opacity 0.15s;
}

.cooccurrence-row:hover .cooccurrence-bar {
  opacity: 0.8;
}

.cooccurrence-filter {
  display: flex;
  gap: 4px;
  margin-bottom: 8px;
  flex-wrap: wrap;
}

.cooccurrence-filter button {
  padding: 3px 8px;
  border: 1px solid var(--border-color);
  border-radius: 4px;
  background: transparent;
  color: var(--text-secondary);
  font-size: 10px;
  cursor: pointer;
  transition: all 0.15s;
}

.cooccurrence-filter button.active {
  background: var(--accent-blue);
  border-color: var(--accent-blue);
  color: var(--bg-primary);
}

.cooccurrence-filter button:hover:not(.active) {
  border-color: var(--text-muted);
  color: var(--text-primary);
}

.cooccurrence-empty {
  font-size: 11px;
  color: var(--text-muted);
  text-align: center;
  padding: 12px 0;
}

/* Graph Container */
.graph-container {
  flex: 1;
  position: relative;
  overflow: hidden;
}

.graph-container svg {
  display: block;
}

/* Tooltip */
.hg-tooltip {
  position: absolute;
  pointer-events: none;
  background: var(--bg-tertiary);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  padding: 10px 12px;
  font-size: 11px;
  line-height: 1.5;
  color: var(--text-secondary);
  box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  z-index: 100;
  max-width: 250px;
}

.hg-tooltip strong {
  color: var(--text-primary);
  font-size: 12px;
}

.hg-tooltip-type {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  background: var(--bg-primary);
  color: var(--text-muted);
  letter-spacing: 0.5px;
}

/* Loading State */
.loading-overlay {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  background: var(--bg-primary);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 50;
  transition: opacity 0.4s;
}

.loading-overlay.hidden {
  opacity: 0;
  pointer-events: none;
}

.loading-spinner {
  width: 36px;
  height: 36px;
  border: 3px solid var(--border-color);
  border-top-color: var(--accent-blue);
  border-radius: 50%;
  animation: spin 0.8s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.loading-text {
  margin-top: 12px;
  font-size: 12px;
  color: var(--text-secondary);
}

/* Hull paths */
.hg-hull {
  pointer-events: none;
}

/* Responsive */
@media (max-width: 800px) {
  .sidebar {
    width: 220px;
    min-width: 220px;
  }
}

/* ============================================================
   Analytics Panel (Right Side)
   ============================================================ */

:root {
  --analytics-width: 360px;
}

/* Analytics Panel */
.analytics-panel {
  width: var(--analytics-width);
  min-width: var(--analytics-width);
  background: var(--bg-secondary);
  border-left: 1px solid var(--border-color);
  display: flex;
  flex-direction: column;
  overflow-y: auto;
  transition: width 0.3s ease, min-width 0.3s ease, opacity 0.3s ease;
}

.analytics-panel.collapsed {
  width: 0;
  min-width: 0;
  overflow: hidden;
  opacity: 0;
  border-left: none;
}

/* Custom scrollbar for analytics panel */
.analytics-panel::-webkit-scrollbar {
  width: 6px;
}

.analytics-panel::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

.analytics-panel::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

.analytics-panel::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

/* Analytics Header */
.analytics-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid var(--border-color);
  flex-shrink: 0;
}

.analytics-header h2 {
  font-size: 15px;
  font-weight: 600;
  letter-spacing: 0.3px;
  color: var(--text-primary);
}

.analytics-collapse-btn {
  background: none;
  border: none;
  color: var(--text-muted);
  font-size: 16px;
  cursor: pointer;
  padding: 4px 8px;
  border-radius: 4px;
  transition: all 0.15s;
  line-height: 1;
}

.analytics-collapse-btn:hover {
  color: var(--text-primary);
  background: var(--bg-tertiary);
}

/* Tab Navigation */
.analytics-tabs {
  display: flex;
  gap: 4px;
  padding: 10px 12px;
  border-bottom: 1px solid var(--border-color);
  overflow-x: auto;
  flex-shrink: 0;
  -webkit-overflow-scrolling: touch;
}

.analytics-tabs::-webkit-scrollbar {
  height: 3px;
}

.analytics-tabs::-webkit-scrollbar-track {
  background: transparent;
}

.analytics-tabs::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 2px;
}

.analytics-tab {
  padding: 6px 12px;
  border: none;
  border-radius: 16px;
  background: transparent;
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 500;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.2s;
  flex-shrink: 0;
}

.analytics-tab:hover {
  color: var(--text-primary);
  background: var(--bg-tertiary);
}

.analytics-tab.active {
  background: var(--accent-blue);
  color: var(--bg-primary);
  font-weight: 600;
}

/* Tab Content */
.analytics-content {
  flex: 1;
  overflow-y: auto;
}

.analytics-content::-webkit-scrollbar {
  width: 6px;
}

.analytics-content::-webkit-scrollbar-track {
  background: var(--bg-secondary);
}

.analytics-content::-webkit-scrollbar-thumb {
  background: var(--border-color);
  border-radius: 3px;
}

.analytics-content::-webkit-scrollbar-thumb:hover {
  background: var(--text-muted);
}

.analytics-tab-content {
  display: none;
  padding: 0;
}

.analytics-tab-content.active {
  display: block;
  animation: fadeInTab 0.25s ease;
}

@keyframes fadeInTab {
  from { opacity: 0; transform: translateY(4px); }
  to   { opacity: 1; transform: translateY(0); }
}

/* Sub-sections */
.analytics-sub-section {
  padding: 14px 16px;
  border-bottom: 1px solid var(--border-color);
}

.analytics-sub-section h4 {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 4px;
}

.analytics-description {
  font-size: 10px;
  color: var(--text-muted);
  line-height: 1.5;
  margin-bottom: 10px;
}

/* Analytics Select (dropdown) */
.analytics-select {
  width: 100%;
  padding: 8px 10px;
  background: var(--bg-primary);
  border: 1px solid var(--border-color);
  border-radius: 6px;
  color: var(--text-primary);
  font-size: 12px;
  outline: none;
  cursor: pointer;
  transition: border-color 0.2s;
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath d='M3 5l3 3 3-3' fill='none' stroke='%236e7681' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 10px center;
  padding-right: 28px;
  margin-bottom: 10px;
}

.analytics-select:focus {
  border-color: var(--accent-blue);
}

.analytics-select option {
  background: var(--bg-secondary);
  color: var(--text-primary);
}

/* Analytics Toggle Button */
.analytics-toggle-btn {
  position: absolute;
  right: 0;
  top: 50%;
  transform: translateY(-50%);
  background: var(--bg-secondary);
  border: 1px solid var(--border-color);
  border-right: none;
  border-radius: 8px 0 0 8px;
  color: var(--text-secondary);
  font-size: 11px;
  font-weight: 500;
  padding: 12px 8px;
  cursor: pointer;
  writing-mode: vertical-rl;
  text-orientation: mixed;
  letter-spacing: 0.5px;
  z-index: 40;
  transition: all 0.25s ease;
  box-shadow: -2px 0 8px rgba(0,0,0,0.2);
}

.analytics-toggle-btn:hover {
  background: var(--bg-tertiary);
  color: var(--text-primary);
}

.analytics-toggle-btn.panel-open {
  right: 0;
  background: var(--accent-blue);
  color: var(--bg-primary);
  border-color: var(--accent-blue);
}

/* ============================================================
   Ranking Items (Centrality, Anomalies, etc.)
   ============================================================ */

.ranking-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 6px;
  background: var(--bg-tertiary);
  margin-bottom: 6px;
  transition: all 0.15s;
  cursor: default;
}

.ranking-item:hover {
  background: rgba(79, 195, 247, 0.08);
  box-shadow: 0 0 0 1px rgba(79, 195, 247, 0.15);
}

.ranking-rank {
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  background: var(--bg-primary);
  color: var(--text-muted);
  font-size: 10px;
  font-weight: 700;
  flex-shrink: 0;
}

.ranking-item:nth-child(1) .ranking-rank {
  background: rgba(255, 183, 77, 0.2);
  color: var(--accent-orange);
}

.ranking-item:nth-child(2) .ranking-rank {
  background: rgba(139, 148, 158, 0.2);
  color: var(--text-secondary);
}

.ranking-item:nth-child(3) .ranking-rank {
  background: rgba(205, 127, 50, 0.2);
  color: #cd7f32;
}

.ranking-info {
  flex: 1;
  min-width: 0;
}

.ranking-name {
  font-size: 11px;
  font-weight: 600;
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.ranking-detail {
  font-size: 9px;
  color: var(--text-muted);
  margin-top: 1px;
}

.ranking-score {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  flex-shrink: 0;
  min-width: 60px;
}

.ranking-score .score-value {
  font-size: 12px;
  font-weight: 700;
  color: var(--accent-blue);
}

.ranking-bar {
  width: 60px;
  height: 4px;
  background: var(--bg-primary);
  border-radius: 2px;
  margin-top: 4px;
  overflow: hidden;
}

.ranking-bar-fill {
  height: 100%;
  border-radius: 2px;
  background: var(--accent-blue);
  transition: width 0.4s ease;
}

/* ============================================================
   Risk Heatmap
   ============================================================ */

.risk-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 6px;
  margin-bottom: 6px;
  background: var(--bg-tertiary);
  transition: all 0.15s;
}

.risk-item:hover {
  box-shadow: 0 0 0 1px rgba(255, 138, 128, 0.2);
}

.risk-bar {
  flex: 1;
  height: 8px;
  background: var(--bg-primary);
  border-radius: 4px;
  overflow: hidden;
  min-width: 60px;
}

.risk-bar-fill {
  height: 100%;
  border-radius: 4px;
  transition: width 0.4s ease;
}

.risk-bar-fill.risk-low {
  background: linear-gradient(90deg, var(--accent-green), #aed581);
}

.risk-bar-fill.risk-medium {
  background: linear-gradient(90deg, #ffd54f, var(--accent-orange));
}

.risk-bar-fill.risk-high {
  background: linear-gradient(90deg, var(--accent-orange), var(--accent-red));
}

.risk-bar-fill.risk-critical {
  background: linear-gradient(90deg, var(--accent-red), #d32f2f);
}

.risk-score {
  font-size: 11px;
  font-weight: 700;
  flex-shrink: 0;
  min-width: 32px;
  text-align: right;
}

.risk-score.risk-low    { color: var(--accent-green); }
.risk-score.risk-medium { color: var(--accent-orange); }
.risk-score.risk-high   { color: var(--accent-red); }
.risk-score.risk-critical { color: #ff5252; }

/* ============================================================
   Cascade Items (Temporal)
   ============================================================ */

.cascade-item {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 6px;
  background: var(--bg-tertiary);
  margin-bottom: 6px;
  transition: all 0.15s;
}

.cascade-item:hover {
  background: rgba(206, 147, 216, 0.08);
}

.cascade-source {
  font-size: 11px;
  font-weight: 600;
  color: var(--accent-blue);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100px;
}

.cascade-arrow {
  flex-shrink: 0;
  color: var(--accent-purple);
  font-size: 14px;
  font-weight: 700;
  letter-spacing: -2px;
}

.cascade-target {
  font-size: 11px;
  font-weight: 600;
  color: var(--accent-orange);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 100px;
}

.cascade-count {
  margin-left: auto;
  font-size: 10px;
  font-weight: 700;
  color: var(--text-muted);
  background: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 10px;
  flex-shrink: 0;
}

/* ============================================================
   Cluster Cards
   ============================================================ */

.cluster-card {
  border-radius: 8px;
  background: var(--bg-tertiary);
  margin-bottom: 8px;
  border-left: 3px solid var(--accent-blue);
  overflow: hidden;
  transition: all 0.15s;
}

.cluster-card:nth-child(2) { border-left-color: var(--accent-orange); }
.cluster-card:nth-child(3) { border-left-color: var(--accent-green); }
.cluster-card:nth-child(4) { border-left-color: var(--accent-purple); }
.cluster-card:nth-child(5) { border-left-color: var(--accent-red); }
.cluster-card:nth-child(6) { border-left-color: #4dd0e1; }
.cluster-card:nth-child(7) { border-left-color: #fff176; }

.cluster-card:hover {
  box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

.cluster-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px 12px;
  cursor: pointer;
  user-select: none;
  transition: background 0.15s;
}

.cluster-header:hover {
  background: rgba(255, 255, 255, 0.03);
}

.cluster-header h5 {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
}

.cluster-stat {
  font-size: 10px;
  color: var(--text-muted);
  font-weight: 600;
  background: var(--bg-primary);
  padding: 2px 8px;
  border-radius: 10px;
}

.cluster-members {
  padding: 0 12px 10px;
  display: none;
}

.cluster-members.expanded {
  display: block;
  animation: fadeInTab 0.2s ease;
}

.cluster-member {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 3px 8px;
  border-radius: 4px;
  background: var(--bg-primary);
  font-size: 10px;
  color: var(--text-secondary);
  margin: 2px 4px 2px 0;
}

/* ============================================================
   Impact Results
   ============================================================ */

.impact-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 6px;
  background: var(--bg-tertiary);
  margin-bottom: 6px;
  transition: all 0.15s;
}

.impact-item:hover {
  background: rgba(79, 195, 247, 0.06);
}

.impact-probability {
  font-size: 12px;
  font-weight: 700;
  flex-shrink: 0;
  min-width: 40px;
  text-align: right;
}

.impact-probability.low    { color: var(--accent-green); }
.impact-probability.medium { color: var(--accent-orange); }
.impact-probability.high   { color: var(--accent-red); }

.impact-bar {
  flex: 1;
  height: 6px;
  background: var(--bg-primary);
  border-radius: 3px;
  overflow: hidden;
  min-width: 40px;
}

.impact-bar-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s ease;
}

.impact-bar-fill.low    { background: var(--accent-green); }
.impact-bar-fill.medium { background: var(--accent-orange); }
.impact-bar-fill.high   { background: var(--accent-red); }

.impact-reason {
  font-size: 9px;
  color: var(--text-muted);
  margin-top: 3px;
}

/* ============================================================
   Incident Items
   ============================================================ */

.incident-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 6px;
  background: var(--bg-tertiary);
  margin-bottom: 6px;
  transition: all 0.15s;
}

.incident-item:hover {
  background: rgba(255, 138, 128, 0.06);
}

.hotspot-item {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 8px 10px;
  border-radius: 6px;
  background: var(--bg-tertiary);
  margin-bottom: 6px;
  transition: all 0.15s;
}

.hotspot-item:hover {
  background: rgba(255, 183, 77, 0.08);
}

.fingerprint-card {
  border-radius: 8px;
  background: var(--bg-tertiary);
  padding: 10px 12px;
  margin-bottom: 8px;
  border-left: 3px solid var(--accent-green);
}

.fingerprint-card h5 {
  font-size: 12px;
  font-weight: 600;
  color: var(--text-primary);
  margin-bottom: 6px;
}

/* ============================================================
   Metric Toggle Buttons (Centrality)
   ============================================================ */

.centrality-metric-toggle {
  display: flex;
  gap: 4px;
  margin-bottom: 10px;
  flex-wrap: wrap;
}

.metric-btn {
  padding: 4px 10px;
  border: 1px solid var(--border-color);
  border-radius: 12px;
  background: transparent;
  color: var(--text-secondary);
  font-size: 10px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.15s;
}

.metric-btn:hover:not(.active) {
  border-color: var(--text-muted);
  color: var(--text-primary);
}

.metric-btn.active {
  background: var(--accent-blue);
  border-color: var(--accent-blue);
  color: var(--bg-primary);
  font-weight: 600;
}

/* ============================================================
   Type Badges
   ============================================================ */

.type-badge {
  display: inline-block;
  padding: 1px 6px;
  border-radius: 8px;
  font-size: 9px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.3px;
}

.type-badge.ci {
  background: rgba(79, 195, 247, 0.15);
  color: var(--accent-blue);
}

.type-badge.group {
  background: rgba(255, 183, 77, 0.15);
  color: var(--accent-orange);
}

.type-badge.service {
  background: rgba(129, 199, 132, 0.15);
  color: var(--accent-green);
}

/* ============================================================
   Alert / Anomaly Styles
   ============================================================ */

.anomaly-alert {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-radius: 6px;
  margin-bottom: 6px;
  font-size: 11px;
  color: var(--text-primary);
}

.anomaly-alert.warning {
  background: rgba(255, 183, 77, 0.1);
  border-left: 3px solid var(--accent-orange);
}

.anomaly-alert.danger {
  background: rgba(255, 138, 128, 0.1);
  border-left: 3px solid var(--accent-red);
}

/* ============================================================
   Trend Indicators
   ============================================================ */

.trend-up {
  color: var(--accent-red);
  font-size: 11px;
  font-weight: 700;
}

.trend-up::before {
  content: "\25B2 ";
  font-size: 8px;
}

.trend-down {
  color: var(--accent-green);
  font-size: 11px;
  font-weight: 700;
}

.trend-down::before {
  content: "\25BC ";
  font-size: 8px;
}

.trend-stable {
  color: var(--text-muted);
  font-size: 11px;
  font-weight: 600;
}

.trend-stable::before {
  content: "\25C6 ";
  font-size: 8px;
}

/* ============================================================
   Analytics Panel — Responsive
   ============================================================ */

@media (max-width: 1200px) {
  .analytics-panel {
    width: 0;
    min-width: 0;
    overflow: hidden;
    opacity: 0;
    border-left: none;
  }

  .analytics-panel.force-open {
    width: var(--analytics-width);
    min-width: var(--analytics-width);
    overflow-y: auto;
    opacity: 1;
    border-left: 1px solid var(--border-color);
    position: absolute;
    right: 0;
    top: 0;
    bottom: 0;
    z-index: 60;
    box-shadow: -4px 0 16px rgba(0,0,0,0.4);
  }
}

  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
  <div class="app-layout">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <h1>BSM Discovery</h1>
        <div class="subtitle">ITIL Hypergraph Explorer</div>
      </div>

      <!-- Query Parameters -->
      <div class="sidebar-section">
        <h3>Query Parameters</h3>
        <div class="query-params">
          <div class="query-param-row">
            <label for="query-limit">sysparm_limit</label>
            <input type="number" id="query-limit" class="query-input" value="100" min="10" max="500" step="10">
          </div>
          <div class="query-param-row">
            <label for="query-start">sys_created_on &gt;=</label>
            <input type="date" id="query-start" class="query-input" value="2025-01-15">
          </div>
          <div class="query-param-row">
            <label for="query-end">sys_created_on &lt;=</label>
            <input type="date" id="query-end" class="query-input" value="2025-04-15">
          </div>
          <button id="query-apply" class="query-apply-btn">Apply Query</button>
          <div class="query-encoded" id="query-encoded"></div>
        </div>
      </div>

      <!-- View Toggle -->
      <div class="sidebar-section">
        <h3>Perspective</h3>
        <div class="view-toggle">
          <button id="btn-original" class="active">Entities → Changes</button>
          <button id="btn-transposed">Changes → Entities</button>
        </div>
        <div class="view-toggle" style="margin-top: 6px;">
          <button id="btn-upset" title="UpSet intersection plot">UpSet Intersections</button>
        </div>
        <div style="margin-top: 8px; text-align: center;">
          <span id="view-label" style="font-size: 10px; color: var(--text-muted);">Original (H)</span>
        </div>
      </div>

      <!-- Stats -->
      <div class="sidebar-section">
        <h3>Statistics</h3>
        <div class="stats-grid">
          <div class="stat-card">
            <div class="stat-value" id="stat-nodes">—</div>
            <div class="stat-label" id="stat-nodes-label">Entity Nodes</div>
          </div>
          <div class="stat-card">
            <div class="stat-value" id="stat-edges">—</div>
            <div class="stat-label" id="stat-edges-label">Change Hyperedges</div>
          </div>
          <div class="stat-card wide">
            <div class="stat-row">
              <span class="stat-label">Density</span>
              <span class="stat-value" id="stat-density">—</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Avg Degree</span>
              <span class="stat-value" id="stat-avg-degree">—</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Max Degree</span>
              <span class="stat-value" id="stat-max-degree">—</span>
            </div>
            <div class="stat-row">
              <span class="stat-label">Avg Edge Size</span>
              <span class="stat-value" id="stat-avg-edge-size">—</span>
            </div>
          </div>
        </div>
      </div>

      <!-- Search -->
      <div class="sidebar-section">
        <h3>Search</h3>
        <input type="text" id="search-input" class="search-input" placeholder="Filter nodes by name…">
      </div>

      <!-- Legend -->
      <div class="sidebar-section">
        <h3>Legend</h3>
        <div class="legend-list">
          <div class="legend-item" data-type="ci">
            <div class="legend-dot" style="background: var(--accent-blue);"></div>
            <span class="legend-label">Configuration Items</span>
            <span class="legend-count" data-type="ci">0</span>
          </div>
          <div class="legend-item" data-type="group">
            <div class="legend-dot" style="background: var(--accent-orange);"></div>
            <span class="legend-label">Support Groups</span>
            <span class="legend-count" data-type="group">0</span>
          </div>
          <div class="legend-item" data-type="service">
            <div class="legend-dot" style="background: var(--accent-green);"></div>
            <span class="legend-label">Business Services</span>
            <span class="legend-count" data-type="service">0</span>
          </div>
          <div class="legend-item" data-type="change">
            <div class="legend-dot" style="background: var(--accent-purple);"></div>
            <span class="legend-label">Change Requests</span>
            <span class="legend-count" data-type="change">0</span>
          </div>
        </div>
      </div>

      <!-- Co-occurrence -->
      <div class="sidebar-section" id="cooccurrence-section">
        <h3>CI Co-occurrence</h3>
        <div class="cooccurrence-filter">
          <button class="cooccurrence-type-btn active" data-filter="">All</button>
          <button class="cooccurrence-type-btn" data-filter="ci">CIs</button>
          <button class="cooccurrence-type-btn" data-filter="group">Groups</button>
          <button class="cooccurrence-type-btn" data-filter="service">Services</button>
        </div>
        <div id="cooccurrence-body"></div>
      </div>

      <!-- Force Controls -->
      <div class="sidebar-section">
        <h3>Force Controls</h3>
        <div class="control-group">
          <div class="control-label">
            <span>Repulsion</span>
            <span class="control-value" id="charge-value">-350</span>
          </div>
          <input type="range" id="charge-slider" min="-600" max="-50" value="-350" step="10">
        </div>
        <div class="control-group">
          <div class="control-label">
            <span>Link Distance</span>
            <span class="control-value" id="link-value">180</span>
          </div>
          <input type="range" id="link-slider" min="40" max="400" value="180" step="10">
        </div>
      </div>

      <!-- Node Detail -->
      <div class="sidebar-section node-detail" id="node-detail">
        <div class="node-detail-header">
          <h3>Node Detail</h3>
          <button class="node-detail-close" id="detail-close">✕</button>
        </div>
        <span class="node-detail-badge" id="detail-badge"></span>
        <div class="node-detail-name" id="detail-name"></div>
        <div id="detail-body" style="margin-top: 8px;"></div>
      </div>
    </aside>

    <!-- Graph Area -->
    <main class="graph-container" id="graph-container">
      <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text" id="loading-text">Initializing…</div>
      </div>
      <button class="analytics-toggle-btn" id="analytics-toggle" title="Toggle Analytics Panel">Analytics ▶</button>
    </main>

    <!-- Analytics Panel (right side) -->
    <aside class="analytics-panel" id="analytics-panel">
      <div class="analytics-header">
        <h2>Analytics</h2>
        <button class="analytics-collapse-btn" id="analytics-collapse" title="Collapse">&#x2715;</button>
      </div>

      <!-- Tab Navigation -->
      <div class="analytics-tabs">
        <button class="analytics-tab active" data-tab="centrality">Centrality</button>
        <button class="analytics-tab" data-tab="temporal">Temporal</button>
        <button class="analytics-tab" data-tab="anomalies">Anomalies</button>
        <button class="analytics-tab" data-tab="clusters">Clusters</button>
        <button class="analytics-tab" data-tab="impact">Impact</button>
        <button class="analytics-tab" data-tab="incidents">Incidents</button>
      </div>

      <!-- Tab Content -->
      <div class="analytics-content">
        <!-- Centrality Tab -->
        <div class="analytics-tab-content active" id="tab-centrality">
          <div class="analytics-sub-section">
            <h4>Critical Nodes</h4>
            <div class="analytics-description">Nodes ranked by composite centrality score (degree + betweenness + eigenvector)</div>
            <div class="centrality-metric-toggle">
              <button class="metric-btn active" data-metric="composite">Composite</button>
              <button class="metric-btn" data-metric="degree">Degree</button>
              <button class="metric-btn" data-metric="betweenness">Betweenness</button>
              <button class="metric-btn" data-metric="eigenvector">Eigenvector</button>
            </div>
            <div id="centrality-rankings"></div>
          </div>
        </div>

        <!-- Temporal Tab -->
        <div class="analytics-tab-content" id="tab-temporal">
          <div class="analytics-sub-section">
            <h4>Change Cascades</h4>
            <div class="analytics-description">CI pairs where changes to one frequently trigger changes to another within 7 days</div>
            <div id="cascade-list"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Change Velocity</h4>
            <div class="analytics-description">CIs with increasing change frequency (potential instability)</div>
            <div id="velocity-list"></div>
          </div>
        </div>

        <!-- Anomalies Tab -->
        <div class="analytics-tab-content" id="tab-anomalies">
          <div class="analytics-sub-section">
            <h4>Risk Heatmap</h4>
            <div class="analytics-description">CIs ranked by composite risk score</div>
            <div id="risk-heatmap"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Unexpected Pairs</h4>
            <div class="analytics-description">CI pairs that co-occur far more than statistically expected</div>
            <div id="unexpected-pairs"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Orphan CIs</h4>
            <div class="analytics-description">CIs rarely or never appearing in changes — blind spots in change management</div>
            <div id="orphan-list"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Over-Coupled Pairs</h4>
            <div class="analytics-description">CIs with Jaccard similarity > 0.5 — excessive dependency risk</div>
            <div id="overcoupled-list"></div>
          </div>
        </div>

        <!-- Clusters Tab -->
        <div class="analytics-tab-content" id="tab-clusters">
          <div class="analytics-sub-section">
            <h4>Detected Communities</h4>
            <div class="analytics-description">Algorithmically discovered CI groups (Louvain method)</div>
            <div id="cluster-summary"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Cluster Details</h4>
            <div id="cluster-details"></div>
          </div>
        </div>

        <!-- Impact Tab -->
        <div class="analytics-tab-content" id="tab-impact">
          <div class="analytics-sub-section">
            <h4>Impact Predictor</h4>
            <div class="analytics-description">Select a CI to predict change impact radius</div>
            <select id="impact-ci-select" class="analytics-select">
              <option value="">Select a CI...</option>
            </select>
            <div id="impact-results"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Predicted Links</h4>
            <div class="analytics-description">CI pairs likely to appear together in future changes (Adamic-Adar index)</div>
            <div id="predicted-links"></div>
          </div>
        </div>

        <!-- Incidents Tab -->
        <div class="analytics-tab-content" id="tab-incidents">
          <div class="analytics-sub-section">
            <h4>Fault Propagation</h4>
            <div class="analytics-description">CIs where incidents cascade to other CIs</div>
            <div id="fault-propagation"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Incident Hotspots</h4>
            <div class="analytics-description">CIs with highest incident frequency</div>
            <div id="incident-hotspots"></div>
          </div>
          <div class="analytics-sub-section">
            <h4>Service Fingerprints</h4>
            <div class="analytics-description">How incidents distribute across each business service's CIs</div>
            <div id="service-fingerprints"></div>
          </div>
        </div>
      </div>
    </aside>
  </div>
  <script>
/* ── ITILDataSimulator ── */
/**
 * ITIL Data Simulator
 *
 * Generates realistic simulated ServiceNow ITIL data for BSM discovery:
 *   - Change requests with assignment groups, business services, and CIs
 *   - Configuration items across multiple CMDB classes
 *   - Support groups and business services with natural clustering
 *   - Incidents with cascading failure modeling and CI clustering
 *
 * Usage:
 *   var sim = new ITILDataSimulator({ changeCount: 50, incidentCount: 30 });
 *   var data = sim.generate();
 *   // data.taskCiRecords — flat task_ci rows with dot-walked fields
 *   // data.incidents     — map of INC number -> incident record
 */

function ITILDataSimulator(options) {
  options = options || {};
  this.changeCount = options.changeCount || 50;
  this.incidentCount = options.incidentCount || 30;
  this.seed = options.seed || 42;
  this._rng = this._createRng(this.seed);

  // Date range: aligns with ServiceNow sysparm_query:
  //   sys_created_on>=startDate^sys_created_on<=endDate
  this.baseDate = options.startDate
    ? new Date(options.startDate + 'T00:00:00Z')
    : new Date('2025-01-15T00:00:00Z');
  this.endDate = options.endDate
    ? new Date(options.endDate + 'T23:59:59Z')
    : new Date(this.baseDate.getTime() + 90 * 24 * 60 * 60 * 1000);

  // sysparm_limit: caps number of change records returned
  if (options.limit != null) {
    this.changeCount = Math.min(this.changeCount, options.limit);
  }
}

// ---------- Deterministic PRNG (mulberry32) ----------

ITILDataSimulator.prototype._createRng = function (seed) {
  var s = seed | 0;
  return function () {
    s = (s + 0x6d2b79f5) | 0;
    var t = Math.imul(s ^ (s >>> 15), 1 | s);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
};

ITILDataSimulator.prototype._pick = function (arr) {
  return arr[Math.floor(this._rng() * arr.length)];
};

ITILDataSimulator.prototype._pickN = function (arr, min, max) {
  var count = min + Math.floor(this._rng() * (max - min + 1));
  var copy = arr.slice();
  var result = [];
  for (var i = 0; i < count && copy.length > 0; i++) {
    var idx = Math.floor(this._rng() * copy.length);
    result.push(copy.splice(idx, 1)[0]);
  }
  return result;
};

ITILDataSimulator.prototype._uuid = function () {
  var hex = '0123456789abcdef';
  var s = '';
  for (var i = 0; i < 32; i++) {
    s += hex[Math.floor(this._rng() * 16)];
    if (i === 7 || i === 11 || i === 15 || i === 19) s += '-';
  }
  return s;
};

/**
 * Generate a random date within a range using the deterministic PRNG.
 * @param {Date} start - Start of the range (inclusive)
 * @param {Date} end   - End of the range (exclusive)
 * @returns {Date}
 */
ITILDataSimulator.prototype._randomDate = function (start, end) {
  var startMs = start.getTime();
  var endMs = end.getTime();
  var randomMs = startMs + Math.floor(this._rng() * (endMs - startMs));
  return new Date(randomMs);
};

// ---------- Reference Data ----------

ITILDataSimulator.GROUPS = [
  { name: 'Network Operations',    focus: ['network_gear'] },
  { name: 'Linux Engineering',     focus: ['linux_server'] },
  { name: 'Windows Engineering',   focus: ['windows_server'] },
  { name: 'Storage Admin',         focus: ['storage'] },
  { name: 'Application Support',   focus: ['application'] },
  { name: 'Database Admin',        focus: ['linux_server', 'windows_server'] },
  { name: 'Cloud Infrastructure',  focus: ['linux_server', 'application'] },
  { name: 'Service Desk',          focus: ['application', 'windows_server'] }
];

ITILDataSimulator.SERVICES = [
  { name: 'Email Service',           ciClasses: ['linux_server', 'application', 'network_gear'] },
  { name: 'ERP Platform',            ciClasses: ['linux_server', 'windows_server', 'storage', 'application'] },
  { name: 'Customer Portal',         ciClasses: ['linux_server', 'application', 'network_gear'] },
  { name: 'HR Management System',    ciClasses: ['windows_server', 'application', 'storage'] },
  { name: 'Data Analytics Platform', ciClasses: ['linux_server', 'storage', 'application'] },
  { name: 'Corporate Network',       ciClasses: ['network_gear', 'linux_server'] }
];

ITILDataSimulator.CI_TEMPLATES = {
  linux_server: {
    names: ['web-lnx', 'app-lnx', 'db-lnx', 'api-lnx', 'batch-lnx', 'cache-lnx', 'mq-lnx', 'etl-lnx', 'log-lnx', 'mon-lnx',
            'proxy-lnx', 'auth-lnx', 'search-lnx', 'report-lnx', 'vault-lnx', 'ci-lnx'],
    osOptions: ['RHEL 8.6', 'RHEL 9.1', 'Ubuntu 22.04', 'CentOS 7.9'],
    models: ['Dell PowerEdge R640', 'Dell PowerEdge R740', 'HP ProLiant DL380 Gen10', 'VMware vSphere VM']
  },
  windows_server: {
    names: ['dc-win', 'file-win', 'print-win', 'app-win', 'sql-win', 'iis-win', 'exchange-win', 'sccm-win', 'rds-win', 'wsus-win',
            'ad-win', 'dns-win'],
    osOptions: ['Windows Server 2019', 'Windows Server 2022'],
    models: ['Dell PowerEdge R640', 'HP ProLiant DL360 Gen10', 'VMware vSphere VM']
  },
  network_gear: {
    names: ['core-sw', 'dist-sw', 'access-sw', 'fw', 'lb', 'router', 'vpn-gw', 'wlan-ctrl', 'edge-sw', 'mgmt-sw'],
    osOptions: ['IOS-XE 17.6', 'NX-OS 10.2', 'FortiOS 7.2', 'PAN-OS 11.0'],
    models: ['Cisco Catalyst 9300', 'Cisco Nexus 9000', 'Fortinet FortiGate 600E', 'Palo Alto PA-5250', 'F5 BIG-IP i5800']
  },
  storage: {
    names: ['san', 'nas', 'backup-store', 'archive', 'object-store', 'block-store'],
    osOptions: ['ONTAP 9.12', 'PowerStore OS 3.0', 'Veeam B&R 12'],
    models: ['NetApp FAS8700', 'Dell PowerStore 500T', 'Pure Storage FlashArray//X70', 'HPE Nimble HF40']
  },
  application: {
    names: ['erp-app', 'crm-app', 'portal-app', 'bi-app', 'hrms-app', 'email-app', 'collab-app', 'workflow-app',
            'analytics-app', 'payment-app', 'inventory-app', 'ticketing-app'],
    osOptions: ['Java 17 / Tomcat 10', 'Node.js 20 LTS', '.NET 8', 'Python 3.11 / Django 5'],
    models: ['Kubernetes Pod', 'Docker Container', 'Azure App Service', 'AWS ECS Task']
  }
};

ITILDataSimulator.REGIONS = ['US-East', 'US-West', 'EU-West', 'EU-Central', 'APAC'];
ITILDataSimulator.RISK_LEVELS = ['Low', 'Medium', 'High', 'Critical'];
ITILDataSimulator.IMPACT_LEVELS = ['1 - High', '2 - Medium', '3 - Low'];
ITILDataSimulator.CHANGE_MODELS = ['Standard', 'Normal', 'Emergency'];

/**
 * Maps CI class names to change categories.
 * When a change touches multiple CI classes, the first matching category wins.
 */
ITILDataSimulator.CLASS_TO_CATEGORY = {
  network_gear: 'Network',
  storage: 'Hardware',
  linux_server: 'Maintenance',
  windows_server: 'Software',
  application: 'Software'
};

/**
 * Category priority order for selecting a single category when multiple CI
 * classes are present in a change. Lower index = higher priority.
 */
ITILDataSimulator.CATEGORY_PRIORITY = ['Security', 'Network', 'Hardware', 'Software', 'Maintenance'];

// ---------- Generation ----------

ITILDataSimulator.prototype.generate = function () {
  var groups = this._generateGroups();
  var services = this._generateServices();
  var cis = this._generateCIs();
  var changes = this._generateChanges(groups, services, cis);
  var incidents = this._generateIncidents(groups, services, cis, changes);

  // Flatten changes into task_ci records (single-query model)
  var taskCiRecords = this._flattenToTaskCi(changes);

  return { taskCiRecords: taskCiRecords, incidents: incidents };
};

/**
 * Flatten internal change records into task_ci rows with dot-walked fields.
 *
 * Each row represents one task_ci M2M record as returned by the ServiceNow
 * Table API with dot-walked fields from change_request (task.*) and
 * cmdb_ci (ci_item.*).
 *
 * @param {Object} changes - Internal change map keyed by CHG number
 * @returns {Array<Object>} Flat task_ci records
 */
ITILDataSimulator.prototype._flattenToTaskCi = function (changes) {
  var records = [];
  var changeNumbers = Object.keys(changes);

  for (var i = 0; i < changeNumbers.length; i++) {
    var chg = changes[changeNumbers[i]];

    for (var j = 0; j < chg.cis.length; j++) {
      var ci = chg.cis[j];
      records.push({
        'task.number':            chg.number,
        'task.type':              chg.model,
        'task.risk':              chg.risk,
        'task.impact':            chg.impact,
        'task.u_impact_region':   chg.region,
        'task.assignment_group':  chg.assignmentGroup.name,
        'task.sys_created_on':    chg.createdAt,
        'ci_item.sys_id':         ci.id,
        'ci_item.name':           ci.name,
        'ci_item.sys_class_name': ci.className,
        'ci_item.u_role':         ci.role,
        'ci_item.ip_address':     ci.ipAddress,
        'ci_item.model_id':       ci.model,
        'ci_item.sys_updated_on': ci.sysUpdatedOn
      });
    }
  }

  return records;
};

ITILDataSimulator.prototype._generateGroups = function () {
  var result = [];
  for (var i = 0; i < ITILDataSimulator.GROUPS.length; i++) {
    var g = ITILDataSimulator.GROUPS[i];
    result.push({ id: this._uuid(), name: g.name, focus: g.focus });
  }
  return result;
};

ITILDataSimulator.prototype._generateServices = function () {
  var result = [];
  for (var i = 0; i < ITILDataSimulator.SERVICES.length; i++) {
    var s = ITILDataSimulator.SERVICES[i];
    result.push({ id: this._uuid(), name: s.name, ciClasses: s.ciClasses });
  }
  return result;
};

ITILDataSimulator.prototype._generateCIs = function () {
  var cis = [];
  var classes = Object.keys(ITILDataSimulator.CI_TEMPLATES);
  var ipCounter = 1;

  for (var c = 0; c < classes.length; c++) {
    var cls = classes[c];
    var tpl = ITILDataSimulator.CI_TEMPLATES[cls];
    for (var n = 0; n < tpl.names.length; n++) {
      var baseName = tpl.names[n];
      var suffix = String(Math.floor(this._rng() * 90) + 10);
      var octet3 = 10 + c;
      var ip = '10.' + octet3 + '.' + Math.floor(ipCounter / 255) + '.' + (ipCounter % 255);
      ipCounter++;
      cis.push({
        id: this._uuid(),
        name: baseName + '-' + suffix,
        className: cls,
        ipAddress: ip,
        role: baseName.split('-')[0],
        os: this._pick(tpl.osOptions),
        model: this._pick(tpl.models),
        sysUpdatedOn: this._randomDate(this.baseDate, this.endDate).toISOString()
      });
    }
  }
  return cis;
};

/**
 * Determine the change category based on the CI classes involved.
 * Uses a priority system: Security and Network take precedence over
 * Hardware, Software, and Maintenance. Emergency changes to network_gear
 * are categorized as Security.
 */
ITILDataSimulator.prototype._determineCategory = function (ciClassNames, changeModel) {
  var candidateCategories = {};
  var i, cls, cat;

  for (i = 0; i < ciClassNames.length; i++) {
    cls = ciClassNames[i];
    cat = ITILDataSimulator.CLASS_TO_CATEGORY[cls];
    if (cat) {
      candidateCategories[cat] = true;
    }
  }

  // Emergency changes involving network gear are categorized as Security
  if (changeModel === 'Emergency' && candidateCategories['Network']) {
    return 'Security';
  }

  // Return highest-priority category found
  var priorities = ITILDataSimulator.CATEGORY_PRIORITY;
  for (i = 0; i < priorities.length; i++) {
    if (candidateCategories[priorities[i]]) {
      return priorities[i];
    }
  }

  return 'Maintenance';
};

ITILDataSimulator.prototype._generateChanges = function (groups, services, cis) {
  var changes = {};
  var cisByClass = {};
  var i, ci;
  var self = this;

  var windowEnd = this.endDate;

  for (i = 0; i < cis.length; i++) {
    ci = cis[i];
    if (!cisByClass[ci.className]) cisByClass[ci.className] = [];
    cisByClass[ci.className].push(ci);
  }

  for (i = 0; i < this.changeCount; i++) {
    var number = 'CHG' + String(i + 1).padStart(4, '0');
    var service = this._pick(services);
    // Prefer groups whose focus overlaps with the service's CI classes
    var compatibleGroups = groups.filter(function (g) {
      return g.focus.some(function (f) { return service.ciClasses.indexOf(f) !== -1; });
    });
    var group = compatibleGroups.length > 0 ? this._pick(compatibleGroups) : this._pick(groups);

    // Pick CIs: prefer classes that match the service
    var candidateCIs = [];
    for (var c = 0; c < service.ciClasses.length; c++) {
      var classPool = cisByClass[service.ciClasses[c]];
      if (classPool) candidateCIs = candidateCIs.concat(classPool);
    }
    if (candidateCIs.length === 0) candidateCIs = cis;
    var selectedCIs = this._pickN(candidateCIs, 1, 5);

    // Timestamps
    var createdAt = this._randomDate(self.baseDate, windowEnd);
    var closeDaysMs = (1 + Math.floor(this._rng() * 14)) * 24 * 60 * 60 * 1000;
    var closedAt = new Date(createdAt.getTime() + closeDaysMs);

    // Change model
    var model = this._pick(ITILDataSimulator.CHANGE_MODELS);

    // Determine category from CI classes involved
    var involvedClasses = [];
    for (var k = 0; k < selectedCIs.length; k++) {
      if (involvedClasses.indexOf(selectedCIs[k].className) === -1) {
        involvedClasses.push(selectedCIs[k].className);
      }
    }
    var category = this._determineCategory(involvedClasses, model);

    changes[number] = {
      number: number,
      region: this._pick(ITILDataSimulator.REGIONS),
      risk: this._pick(ITILDataSimulator.RISK_LEVELS),
      impact: this._pick(ITILDataSimulator.IMPACT_LEVELS),
      model: model,
      category: category,
      assignmentGroup: { id: group.id, name: group.name },
      businessService: { id: service.id, name: service.name },
      createdAt: createdAt.toISOString(),
      closedAt: closedAt.toISOString(),
      cis: selectedCIs.map(function (ci) {
        return { id: ci.id, name: ci.name, className: ci.className, ipAddress: ci.ipAddress, role: ci.role, os: ci.os, model: ci.model, sysUpdatedOn: ci.sysUpdatedOn };
      })
    };
  }

  return changes;
};

/**
 * Generate incident records with realistic clustering and cascading behavior.
 *
 * - Some CIs are marked as "problematic" and attract more incidents.
 * - When a problematic CI gets an incident, related CIs (those that share
 *   changes) have a ~40% chance of receiving a cascading incident 1-4 hours later.
 * - Priority affects resolution time: P1 = 1-6h, P2 = 2-12h, P3 = 4-24h, P4 = 8-48h.
 */
ITILDataSimulator.prototype._generateIncidents = function (groups, services, cis, changes) {
  var incidents = {};
  var self = this;
  var windowEnd = this.endDate;

  // Build a map of CI id -> list of other CI ids that share at least one change
  var ciNeighbors = {};
  var changeKeys = Object.keys(changes);
  var i, j, chg, ciId;

  for (i = 0; i < changeKeys.length; i++) {
    chg = changes[changeKeys[i]];
    var chgCiIds = [];
    for (j = 0; j < chg.cis.length; j++) {
      chgCiIds.push(chg.cis[j].id);
    }
    // Every pair of CIs in this change are neighbors
    for (j = 0; j < chgCiIds.length; j++) {
      if (!ciNeighbors[chgCiIds[j]]) ciNeighbors[chgCiIds[j]] = {};
      for (var k = 0; k < chgCiIds.length; k++) {
        if (j !== k) {
          ciNeighbors[chgCiIds[j]][chgCiIds[k]] = true;
        }
      }
    }
  }

  // Build a lookup from CI id to CI object
  var ciById = {};
  for (i = 0; i < cis.length; i++) {
    ciById[cis[i].id] = cis[i];
  }

  // Select ~20% of CIs as "problematic" — they will attract more incidents
  var problematicCount = Math.max(3, Math.floor(cis.length * 0.2));
  var problematicCIs = this._pickN(cis, problematicCount, problematicCount);
  var problematicIds = {};
  for (i = 0; i < problematicCIs.length; i++) {
    problematicIds[problematicCIs[i].id] = true;
  }

  // Build a weighted CI pool: problematic CIs appear 4x more often
  var weightedCIPool = [];
  for (i = 0; i < cis.length; i++) {
    weightedCIPool.push(cis[i]);
    if (problematicIds[cis[i].id]) {
      weightedCIPool.push(cis[i]);
      weightedCIPool.push(cis[i]);
      weightedCIPool.push(cis[i]);
    }
  }

  // Find services that a CI belongs to (via changes)
  var ciToServices = {};
  for (i = 0; i < changeKeys.length; i++) {
    chg = changes[changeKeys[i]];
    for (j = 0; j < chg.cis.length; j++) {
      ciId = chg.cis[j].id;
      if (!ciToServices[ciId]) ciToServices[ciId] = {};
      ciToServices[ciId][chg.businessService.id] = chg.businessService;
    }
  }

  // Resolution time ranges by priority (in hours): [min, max]
  var resolutionRanges = {
    1: [1, 6],
    2: [2, 12],
    3: [4, 24],
    4: [8, 48]
  };

  var incidentNumber = 0;
  var pendingIncidents = []; // queue of incidents to create (including cascading)

  // Seed the queue with primary incidents
  var primaryCount = this.incidentCount;
  for (i = 0; i < primaryCount; i++) {
    var affectedCI = this._pick(weightedCIPool);
    var priority = this._rng() < 0.15 ? 1 : (this._rng() < 0.3 ? 2 : (this._rng() < 0.6 ? 3 : 4));
    var createdAt = this._randomDate(self.baseDate, windowEnd);

    pendingIncidents.push({
      affectedCI: affectedCI,
      priority: priority,
      createdAt: createdAt,
      isCascade: false
    });
  }

  // Process the queue: for each incident, potentially spawn cascading incidents
  var allIncidentNumbers = [];
  var processedCount = 0;

  while (processedCount < pendingIncidents.length) {
    var pending = pendingIncidents[processedCount];
    processedCount++;

    incidentNumber++;
    var incNum = 'INC' + String(incidentNumber).padStart(4, '0');
    allIncidentNumbers.push(incNum);

    var ci = pending.affectedCI;
    var prio = pending.priority;
    var created = pending.createdAt;

    // Resolution time based on priority
    var range = resolutionRanges[prio];
    var resolveHours = range[0] + Math.floor(this._rng() * (range[1] - range[0] + 1));
    var resolvedAt = new Date(created.getTime() + resolveHours * 60 * 60 * 1000);

    // Find a business service for this CI
    var serviceRef;
    if (ciToServices[ci.id]) {
      var serviceKeys = Object.keys(ciToServices[ci.id]);
      var svcKey = serviceKeys[Math.floor(this._rng() * serviceKeys.length)];
      var svc = ciToServices[ci.id][svcKey];
      serviceRef = { id: svc.id, name: svc.name };
    } else {
      // Fallback: pick a random service
      var fallbackSvc = this._pick(services);
      serviceRef = { id: fallbackSvc.id, name: fallbackSvc.name };
    }

    // Pick an assignment group whose focus matches the CI class
    var matchingGroups = groups.filter(function (g) {
      return g.focus.indexOf(ci.className) !== -1;
    });
    var assignedGroup = matchingGroups.length > 0 ? this._pick(matchingGroups) : this._pick(groups);

    incidents[incNum] = {
      number: incNum,
      priority: prio,
      affectedCI: { id: ci.id, name: ci.name },
      businessService: serviceRef,
      createdAt: created.toISOString(),
      resolvedAt: resolvedAt.toISOString(),
      relatedIncidents: [],
      assignmentGroup: { id: assignedGroup.id, name: assignedGroup.name }
    };

    // Cascading failure: ~40% chance for each neighbor CI (only from non-cascade incidents
    // and only if we haven't exceeded a reasonable total)
    if (!pending.isCascade && ciNeighbors[ci.id] && pendingIncidents.length < primaryCount * 3) {
      var neighborIds = Object.keys(ciNeighbors[ci.id]);
      for (j = 0; j < neighborIds.length; j++) {
        if (this._rng() < 0.4) {
          var neighborCI = ciById[neighborIds[j]];
          if (!neighborCI) continue;

          // Cascading incident occurs 1-4 hours after the original
          var cascadeDelayHours = 1 + Math.floor(this._rng() * 4);
          var cascadeCreated = new Date(created.getTime() + cascadeDelayHours * 60 * 60 * 1000);

          // Cascading incidents tend to be same priority or one level lower
          var cascadePrio = prio;
          if (this._rng() < 0.4 && cascadePrio < 4) {
            cascadePrio = cascadePrio + 1;
          }

          pendingIncidents.push({
            affectedCI: neighborCI,
            priority: cascadePrio,
            createdAt: cascadeCreated,
            isCascade: true,
            parentIncNum: incNum
          });
        }
      }
    }
  }

  // Wire up relatedIncidents: cascading incidents reference their parent,
  // and parents reference their cascades
  for (i = 0; i < pendingIncidents.length; i++) {
    if (pendingIncidents[i].isCascade && pendingIncidents[i].parentIncNum) {
      // The cascade incident number is i+1 (1-indexed)
      var cascadeNum = 'INC' + String(i + 1).padStart(4, '0');
      var parentNum = pendingIncidents[i].parentIncNum;

      if (incidents[cascadeNum] && incidents[parentNum]) {
        // Add parent to cascade's relatedIncidents (max 2)
        if (incidents[cascadeNum].relatedIncidents.length < 2) {
          incidents[cascadeNum].relatedIncidents.push(parentNum);
        }
        // Add cascade to parent's relatedIncidents (max 2)
        if (incidents[parentNum].relatedIncidents.length < 2) {
          incidents[parentNum].relatedIncidents.push(cascadeNum);
        }
      }
    }
  }

  return incidents;
};

/* ── HypergraphCore ── */
/**
 * HypergraphCore — Transposable Incidence-Matrix Hypergraph
 *
 * Builds a hypergraph from ITILDataSimulator output where:
 *   Original (H):  nodes = entities (CIs, groups, services)
 *                   hyperedges = change requests
 *   Transposed (H*): nodes = change requests
 *                     hyperedges = entities
 *
 * The incidence matrix is stored as a dictionary-of-sets for efficient
 * membership queries and O(1) transpose via key/value swap.
 *
 * Usage:
 *   var sim = new ITILDataSimulator();
 *   var data = sim.generate();
 *   var hg = new HypergraphCore();
 *   var graph = hg.build(data);         // original view
 *   var dual  = hg.transpose(graph);    // transposed view
 */

function HypergraphCore() {}

/**
 * Build the original hypergraph from task_ci records.
 *
 * Flat task_ci rows (each a change–CI pairing with dot-walked fields) are
 * grouped by task.number to form change hyperedges, and deduplicated by
 * ci_item.sys_id to form CI nodes.
 *
 * @param {Object} data - Output of ITILDataSimulator.generate()
 *   data.taskCiRecords — array of flat task_ci rows
 * @returns {Object} Hypergraph descriptor { nodes, edges, incidence, stats, isTransposed }
 */
HypergraphCore.prototype.build = function (data) {
  var records = data.taskCiRecords;
  var nodes = [];
  var nodeMap = {};  // uid -> node object
  var edges = [];
  var incidence = {}; // nodeUid -> Set of edgeUids

  var i, j;

  // Pass 1: Extract unique CIs as nodes
  var ciSeen = {};
  for (i = 0; i < records.length; i++) {
    var rec = records[i];
    var ciSysId = rec['ci_item.sys_id'];
    if (!ciSeen[ciSysId]) {
      ciSeen[ciSysId] = true;
      var node = {
        uid: 'ci:' + ciSysId,
        type: 'ci',
        name: rec['ci_item.name'],
        className: rec['ci_item.sys_class_name'],
        ipAddress: rec['ci_item.ip_address'],
        role: rec['ci_item.u_role'],
        model: rec['ci_item.model_id'],
        sysUpdatedOn: rec['ci_item.sys_updated_on']
      };
      nodes.push(node);
      nodeMap[node.uid] = node;
      incidence[node.uid] = new Set();
    }
  }

  // Pass 2: Group records by change number to build hyperedges
  var changeGroups = {};
  for (j = 0; j < records.length; j++) {
    var r = records[j];
    var chgNum = r['task.number'];
    if (!changeGroups[chgNum]) {
      changeGroups[chgNum] = {
        number: chgNum,
        changeType: r['task.type'],
        risk: r['task.risk'],
        impact: r['task.impact'],
        region: r['task.u_impact_region'],
        assignmentGroup: r['task.assignment_group'],
        createdAt: r['task.sys_created_on'],
        ciUids: []
      };
    }
    changeGroups[chgNum].ciUids.push('ci:' + r['ci_item.sys_id']);
  }

  // Build hyperedges from grouped changes
  var chgNums = Object.keys(changeGroups);
  for (var e = 0; e < chgNums.length; e++) {
    var chg = changeGroups[chgNums[e]];
    var edgeUid = 'change:' + chg.number;
    var members = [];

    for (var m = 0; m < chg.ciUids.length; m++) {
      if (nodeMap[chg.ciUids[m]]) members.push(chg.ciUids[m]);
    }

    var edge = {
      uid: edgeUid,
      elements: members,
      number: chg.number,
      changeType: chg.changeType,
      risk: chg.risk,
      impact: chg.impact,
      region: chg.region,
      assignmentGroup: chg.assignmentGroup,
      createdAt: chg.createdAt
    };
    edges.push(edge);

    // Populate incidence matrix
    for (var mi = 0; mi < members.length; mi++) {
      incidence[members[mi]].add(edgeUid);
    }
  }

  return {
    nodes: nodes,
    edges: edges,
    incidence: incidence,
    stats: this._computeStats(nodes, edges, incidence),
    isTransposed: false
  };
};

/**
 * Transpose the hypergraph: swap nodes and hyperedges.
 *
 * In the transposed view, each original hyperedge (change request) becomes
 * a node, and each original node (entity) becomes a hyperedge grouping
 * all changes that involve it.
 *
 * @param {Object} graph - Original hypergraph from build()
 * @returns {Object} Transposed hypergraph with same schema
 */
HypergraphCore.prototype.transpose = function (graph) {
  var newNodes = [];
  var newEdges = [];
  var newIncidence = {};

  var i, j;

  // Original edges become new nodes
  for (i = 0; i < graph.edges.length; i++) {
    var oldEdge = graph.edges[i];
    newNodes.push({
      uid: oldEdge.uid,
      type: 'change',
      name: oldEdge.number,
      changeType: oldEdge.changeType,
      risk: oldEdge.risk,
      impact: oldEdge.impact,
      region: oldEdge.region,
      assignmentGroup: oldEdge.assignmentGroup,
      createdAt: oldEdge.createdAt
    });
    newIncidence[oldEdge.uid] = new Set();
  }

  // Original nodes become new hyperedges
  for (i = 0; i < graph.nodes.length; i++) {
    var oldNode = graph.nodes[i];
    var memberEdgeUids = graph.incidence[oldNode.uid];
    if (!memberEdgeUids || memberEdgeUids.size === 0) continue;

    var elements = Array.from(memberEdgeUids);
    newEdges.push({
      uid: oldNode.uid,
      elements: elements,
      type: oldNode.type,
      name: oldNode.name,
      className: oldNode.className,
      ipAddress: oldNode.ipAddress
    });

    // Populate transposed incidence
    for (j = 0; j < elements.length; j++) {
      newIncidence[elements[j]].add(oldNode.uid);
    }
  }

  return {
    nodes: newNodes,
    edges: newEdges,
    incidence: newIncidence,
    stats: this._computeStats(newNodes, newEdges, newIncidence),
    isTransposed: true
  };
};

/**
 * Compute summary statistics for a hypergraph.
 */
HypergraphCore.prototype._computeStats = function (nodes, edges, incidence) {
  var totalNodes = nodes.length;
  var totalEdges = edges.length;

  // Density: ratio of actual incidence entries to possible (nodes * edges)
  var incidenceCount = 0;
  var nodeUids = Object.keys(incidence);
  var maxDegree = 0;
  var minDegree = Infinity;
  var degreeSum = 0;

  for (var i = 0; i < nodeUids.length; i++) {
    var deg = incidence[nodeUids[i]].size;
    incidenceCount += deg;
    degreeSum += deg;
    if (deg > maxDegree) maxDegree = deg;
    if (deg < minDegree) minDegree = deg;
  }

  var maxPossible = totalNodes * totalEdges;
  var density = maxPossible > 0 ? incidenceCount / maxPossible : 0;
  var avgDegree = totalNodes > 0 ? degreeSum / totalNodes : 0;

  // Edge size stats
  var maxEdgeSize = 0;
  var minEdgeSize = Infinity;
  var edgeSizeSum = 0;
  for (var e = 0; e < edges.length; e++) {
    var sz = edges[e].elements.length;
    edgeSizeSum += sz;
    if (sz > maxEdgeSize) maxEdgeSize = sz;
    if (sz < minEdgeSize) minEdgeSize = sz;
  }
  var avgEdgeSize = totalEdges > 0 ? edgeSizeSum / totalEdges : 0;

  return {
    totalNodes: totalNodes,
    totalEdges: totalEdges,
    density: Math.round(density * 10000) / 10000,
    avgDegree: Math.round(avgDegree * 100) / 100,
    maxDegree: maxDegree,
    minDegree: minDegree === Infinity ? 0 : minDegree,
    avgEdgeSize: Math.round(avgEdgeSize * 100) / 100,
    maxEdgeSize: maxEdgeSize,
    minEdgeSize: minEdgeSize === Infinity ? 0 : minEdgeSize
  };
};

/**
 * Compute the co-occurrence projection matrix (H × Hᵀ) for a given node type.
 *
 * Returns ranked pairs of nodes that share the most hyperedges, along with
 * the UIDs of the shared edges for drill-down.
 *
 * @param {Object} graph - Hypergraph from build() or transpose()
 * @param {string} [filterType] - Only include nodes of this type (e.g. 'ci'). Null = all.
 * @param {number} [topN] - Return only top N pairs. Default 20.
 * @returns {Array<{a: string, b: string, count: number, sharedEdges: string[]}>}
 */
HypergraphCore.prototype.cooccurrence = function (graph, filterType, topN) {
  topN = topN || 20;

  // Build edge -> member list lookup
  var edgeMembers = {};
  for (var e = 0; e < graph.edges.length; e++) {
    var edge = graph.edges[e];
    var members = edge.elements;
    if (filterType) {
      members = members.filter(function (uid) {
        // Match node type from uid prefix or from node lookup
        return uid.indexOf(filterType + ':') === 0;
      });
    }
    if (members.length > 1) {
      edgeMembers[edge.uid] = members;
    }
  }

  // Count pairwise co-occurrences
  var pairMap = {}; // "a|b" -> { count, sharedEdges }
  var edgeUids = Object.keys(edgeMembers);
  for (var i = 0; i < edgeUids.length; i++) {
    var eUid = edgeUids[i];
    var mems = edgeMembers[eUid];
    for (var a = 0; a < mems.length; a++) {
      for (var b = a + 1; b < mems.length; b++) {
        var key = mems[a] < mems[b] ? mems[a] + '|' + mems[b] : mems[b] + '|' + mems[a];
        if (!pairMap[key]) {
          pairMap[key] = { a: key.split('|')[0], b: key.split('|')[1], count: 0, sharedEdges: [] };
        }
        pairMap[key].count++;
        pairMap[key].sharedEdges.push(eUid);
      }
    }
  }

  // Sort by count descending and return top N
  var pairs = Object.values(pairMap);
  pairs.sort(function (x, y) { return y.count - x.count; });
  return pairs.slice(0, topN);
};

/**
 * Find nodes that belong to the same hyperedges as the given node.
 * Useful for neighborhood exploration.
 *
 * @param {Object} graph - Hypergraph
 * @param {string} nodeUid - Node to explore from
 * @returns {string[]} UIDs of co-member nodes (excluding the input node)
 */
HypergraphCore.prototype.neighbors = function (graph, nodeUid) {
  var edgeSet = graph.incidence[nodeUid];
  if (!edgeSet) return [];

  var neighborSet = new Set();
  var edgeUids = Array.from(edgeSet);

  for (var i = 0; i < edgeUids.length; i++) {
    var edge = null;
    for (var e = 0; e < graph.edges.length; e++) {
      if (graph.edges[e].uid === edgeUids[i]) { edge = graph.edges[e]; break; }
    }
    if (!edge) continue;
    for (var j = 0; j < edge.elements.length; j++) {
      if (edge.elements[j] !== nodeUid) {
        neighborSet.add(edge.elements[j]);
      }
    }
  }

  return Array.from(neighborSet);
};

/* ── BSMHypergraphRenderer ── */
/**
 * BSM Hypergraph Renderer — D3 Force-Directed Visualization
 *
 * Renders a HypergraphCore output as a force-directed graph with convex hull
 * overlays for hyperedges. Supports both original and transposed views.
 * Enhanced with analytics-driven visualization: centrality sizing, cluster
 * coloring, anomaly pulses, and cascade overlays.
 *
 * Usage:
 *   var renderer = new BSMHypergraphRenderer('#graph-container');
 *   renderer.render(hypergraphData);
 *   renderer.render(transposedData); // re-renders on transpose
 */

/* global d3 */

function BSMHypergraphRenderer(containerSelector, options) {
  options = options || {};
  this.containerSelector = containerSelector;
  this.width = options.width || 960;
  this.height = options.height || 700;
  this.simulation = null;
  this.svg = null;
  this.zoom = null;
  this.currentGraph = null;
  this._hullPadding = 30;
  this._searchTerm = '';
  this._hiddenTypes = new Set();
  this._onNodeClick = options.onNodeClick || null;
  this._onStatsUpdate = options.onStatsUpdate || null;

  // Analytics overlay state
  this._vizMode = 'type'; // 'type' | 'centrality' | 'cluster' | 'risk'
  this._centralityScores = null;   // { nodeUid: score }
  this._centralityMetric = 'composite';
  this._clusterAssignments = null; // { nodeUid: clusterId }
  this._riskScores = null;         // { nodeUid: score 0-100 }
  this._anomalyNodes = new Set();  // UIDs of anomalous nodes
  this._cascadeOverlays = [];      // [{ source, target, count }]

  // Color schemes
  this._nodeColors = {
    ci: '#4fc3f7',
    group: '#ffb74d',
    service: '#81c784',
    change: '#ce93d8'
  };
  // Cluster palette — 12 distinct hues for community detection
  this._clusterPalette = [
    '#4fc3f7', '#ff8a65', '#81c784', '#ce93d8',
    '#ffd54f', '#4dd0e1', '#f48fb1', '#a5d6a7',
    '#90caf9', '#ffab91', '#80cbc4', '#e6ee9c'
  ];
  // Risk gradient stops
  this._riskGradient = function (score) {
    if (score < 25) return '#81c784';
    if (score < 50) return '#ffd54f';
    if (score < 75) return '#ffb74d';
    return '#ff8a80';
  };
  this._hullPalette = [
    'rgba(79, 195, 247, 0.08)',
    'rgba(255, 183, 77, 0.08)',
    'rgba(129, 199, 132, 0.08)',
    'rgba(206, 147, 216, 0.08)',
    'rgba(255, 138, 128, 0.08)',
    'rgba(128, 222, 234, 0.08)',
    'rgba(255, 213, 79, 0.08)',
    'rgba(174, 213, 129, 0.08)',
    'rgba(144, 164, 174, 0.08)',
    'rgba(239, 154, 154, 0.08)'
  ];
  this._hullStrokePalette = [
    'rgba(79, 195, 247, 0.35)',
    'rgba(255, 183, 77, 0.35)',
    'rgba(129, 199, 132, 0.35)',
    'rgba(206, 147, 216, 0.35)',
    'rgba(255, 138, 128, 0.35)',
    'rgba(128, 222, 234, 0.35)',
    'rgba(255, 213, 79, 0.35)',
    'rgba(174, 213, 129, 0.35)',
    'rgba(144, 164, 174, 0.35)',
    'rgba(239, 154, 154, 0.35)'
  ];
}

// ---------- Initialization ----------

BSMHypergraphRenderer.prototype._initSVG = function () {
  var container = d3.select(this.containerSelector);
  container.selectAll('*').remove();

  var rect = container.node().getBoundingClientRect();
  this.width = rect.width || this.width;
  this.height = rect.height || this.height;

  this.svg = container.append('svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('viewBox', '0 0 ' + this.width + ' ' + this.height);

  var defs = this.svg.append('defs');
  // Glow filter for highlighted nodes
  var filter = defs.append('filter').attr('id', 'glow');
  filter.append('feGaussianBlur').attr('stdDeviation', '3').attr('result', 'coloredBlur');
  var feMerge = filter.append('feMerge');
  feMerge.append('feMergeNode').attr('in', 'coloredBlur');
  feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

  // Anomaly pulse filter (stronger glow in red)
  var anomalyFilter = defs.append('filter').attr('id', 'anomaly-pulse');
  anomalyFilter.append('feGaussianBlur').attr('stdDeviation', '4').attr('result', 'coloredBlur');
  var anomalyMerge = anomalyFilter.append('feMerge');
  anomalyMerge.append('feMergeNode').attr('in', 'coloredBlur');
  anomalyMerge.append('feMergeNode').attr('in', 'SourceGraphic');

  // Arrow marker for cascade overlays
  defs.append('marker')
    .attr('id', 'cascade-arrow')
    .attr('viewBox', '0 0 10 10')
    .attr('refX', 20)
    .attr('refY', 5)
    .attr('markerWidth', 6)
    .attr('markerHeight', 6)
    .attr('orient', 'auto-start-reverse')
    .append('path')
    .attr('d', 'M 0 0 L 10 5 L 0 10 z')
    .attr('fill', '#ff8a80');

  // Main group for zoom/pan
  this._g = this.svg.append('g').attr('class', 'graph-layer');
  this._hullLayer = this._g.append('g').attr('class', 'hull-layer');
  this._linkLayer = this._g.append('g').attr('class', 'link-layer');
  this._cascadeLayer = this._g.append('g').attr('class', 'cascade-layer');
  this._nodeLayer = this._g.append('g').attr('class', 'node-layer');
  this._pulseLayer = this._g.append('g').attr('class', 'pulse-layer');
  this._labelLayer = this._g.append('g').attr('class', 'label-layer');

  // Tooltip
  this._tooltip = container.append('div')
    .attr('class', 'hg-tooltip')
    .style('opacity', 0);

  // Zoom behavior
  var self = this;
  this.zoom = d3.zoom()
    .scaleExtent([0.1, 8])
    .on('zoom', function (event) {
      self._g.attr('transform', event.transform);
    });
  this.svg.call(this.zoom);
};

// ---------- Rendering ----------

BSMHypergraphRenderer.prototype.render = function (graph) {
  this.currentGraph = graph;
  this._initSVG();

  var self = this;
  var nodes = graph.nodes.slice();
  var edges = graph.edges.slice();

  // Build node lookup
  var nodeById = {};
  for (var i = 0; i < nodes.length; i++) {
    nodeById[nodes[i].uid] = nodes[i];
    nodes[i].x = this.width / 2 + (Math.random() - 0.5) * 200;
    nodes[i].y = this.height / 2 + (Math.random() - 0.5) * 200;
  }

  // Build links from hyperedge membership (for force simulation)
  var links = [];
  var linkSet = new Set();
  for (var e = 0; e < edges.length; e++) {
    var members = edges[e].elements;
    // Create pairwise links within each hyperedge (for force layout)
    for (var a = 0; a < members.length; a++) {
      for (var b = a + 1; b < members.length; b++) {
        var key = members[a] < members[b] ? members[a] + '|' + members[b] : members[b] + '|' + members[a];
        if (!linkSet.has(key) && nodeById[members[a]] && nodeById[members[b]]) {
          linkSet.add(key);
          links.push({ source: members[a], target: members[b], edgeUid: edges[e].uid });
        }
      }
    }
  }

  // Force simulation — expanded default: strong repulsion, long links
  this.simulation = d3.forceSimulation(nodes)
    .force('link', d3.forceLink(links).id(function (d) { return d.uid; }).distance(180).strength(0.15))
    .force('charge', d3.forceManyBody().strength(-350))
    .force('center', d3.forceCenter(this.width / 2, this.height / 2))
    .force('collision', d3.forceCollide().radius(24))
    .force('x', d3.forceX(this.width / 2).strength(0.015))
    .force('y', d3.forceY(this.height / 2).strength(0.015));

  // Draw links
  var linkSelection = this._linkLayer.selectAll('line')
    .data(links)
    .enter().append('line')
    .attr('class', 'hg-link')
    .attr('stroke', '#333')
    .attr('stroke-opacity', 0.15)
    .attr('stroke-width', 0.5);

  // Draw nodes — color and size driven by current vizMode
  var nodeSelection = this._nodeLayer.selectAll('circle')
    .data(nodes)
    .enter().append('circle')
    .attr('class', 'hg-node')
    .attr('r', function (d) { return self._computeRadius(d); })
    .attr('fill', function (d) { return self._computeColor(d); })
    .attr('stroke', function (d) { return d3.color(self._computeColor(d)).darker(0.5); })
    .attr('stroke-width', 1.5)
    .call(d3.drag()
      .on('start', function (event, d) { self._dragStart(event, d); })
      .on('drag', function (event, d) { self._dragMove(event, d); })
      .on('end', function (event, d) { self._dragEnd(event, d); }))
    .on('mouseover', function (event, d) { self._showTooltip(event, d); })
    .on('mouseout', function () { self._hideTooltip(); })
    .on('click', function (event, d) { self._handleNodeClick(event, d); });

  // Draw anomaly pulse rings
  if (this._anomalyNodes.size > 0) {
    var anomalyData = nodes.filter(function (n) { return self._anomalyNodes.has(n.uid); });
    this._pulseLayer.selectAll('circle')
      .data(anomalyData)
      .enter().append('circle')
      .attr('class', 'anomaly-ring')
      .attr('r', function (d) { return self._computeRadius(d) + 6; })
      .attr('fill', 'none')
      .attr('stroke', '#ff8a80')
      .attr('stroke-width', 2)
      .attr('stroke-dasharray', '4,3')
      .attr('opacity', 0.7)
      .attr('filter', 'url(#anomaly-pulse)');
  }

  // Draw labels
  var labelSelection = this._labelLayer.selectAll('text')
    .data(nodes)
    .enter().append('text')
    .attr('class', 'hg-label')
    .attr('text-anchor', 'middle')
    .attr('dy', function (d) { return self._nodeRadius(d) + 12; })
    .attr('fill', '#aaa')
    .attr('font-size', '9px')
    .text(function (d) { return d.name; });

  // Store selections for analytics updates
  this._currentNodes = nodeSelection;
  this._currentLabels = labelSelection;
  this._currentLinks = linkSelection;
  this._currentNodeById = nodeById;

  // Tick handler
  var pulseSelection = this._pulseLayer.selectAll('circle');
  this.simulation.on('tick', function () {
    linkSelection
      .attr('x1', function (d) { return d.source.x; })
      .attr('y1', function (d) { return d.source.y; })
      .attr('x2', function (d) { return d.target.x; })
      .attr('y2', function (d) { return d.target.y; });

    nodeSelection
      .attr('cx', function (d) { return d.x; })
      .attr('cy', function (d) { return d.y; })
      .attr('display', function (d) { return self._isVisible(d) ? null : 'none'; });

    labelSelection
      .attr('x', function (d) { return d.x; })
      .attr('y', function (d) { return d.y; })
      .attr('display', function (d) { return self._isVisible(d) ? null : 'none'; });

    // Pulse rings follow their nodes
    pulseSelection
      .attr('cx', function (d) { return d.x; })
      .attr('cy', function (d) { return d.y; })
      .attr('display', function (d) { return self._isVisible(d) ? null : 'none'; });

    // Cascade arrows follow their source/target nodes
    self._cascadeLayer.selectAll('line')
      .attr('x1', function (d) { return d.sourceNode ? d.sourceNode.x : 0; })
      .attr('y1', function (d) { return d.sourceNode ? d.sourceNode.y : 0; })
      .attr('x2', function (d) { return d.targetNode ? d.targetNode.x : 0; })
      .attr('y2', function (d) { return d.targetNode ? d.targetNode.y : 0; });

    self._drawHulls(edges, nodeById);
  });

  // Notify stats
  if (this._onStatsUpdate) {
    this._onStatsUpdate(graph.stats, graph.isTransposed);
  }
};

// ---------- Convex Hull Rendering ----------

BSMHypergraphRenderer.prototype._drawHulls = function (edges, nodeById) {
  var self = this;
  this._hullLayer.selectAll('path').remove();

  // Smooth closed curve generator (Catmull-Rom spline)
  var smoothHull = d3.line()
    .x(function (d) { return d[0]; })
    .y(function (d) { return d[1]; })
    .curve(d3.curveCatmullRomClosed.alpha(0.5));

  for (var i = 0; i < edges.length; i++) {
    var edge = edges[i];
    var points = [];

    for (var m = 0; m < edge.elements.length; m++) {
      var node = nodeById[edge.elements[m]];
      if (node && node.x != null && self._isVisible(node)) {
        // Generate radial padding points around each node for a rounder hull
        var pad = self._hullPadding;
        var steps = 8;
        for (var s = 0; s < steps; s++) {
          var angle = (2 * Math.PI * s) / steps;
          points.push([node.x + pad * Math.cos(angle), node.y + pad * Math.sin(angle)]);
        }
      }
    }

    if (points.length < 6) continue; // Need at least 2 nodes

    var hull = d3.polygonHull(points);
    if (!hull) continue;

    var colorIdx = i % this._hullPalette.length;

    this._hullLayer.append('path')
      .attr('d', smoothHull(hull))
      .attr('fill', this._hullPalette[colorIdx])
      .attr('stroke', this._hullStrokePalette[colorIdx])
      .attr('stroke-width', 1.5)
      .attr('class', 'hg-hull');
  }
};

// ---------- Node Sizing (Analytics-Aware) ----------

BSMHypergraphRenderer.prototype._nodeRadius = function (d) {
  if (d.type === 'service') return 10;
  if (d.type === 'group') return 9;
  if (d.type === 'change') return 8;
  return 6; // ci
};

/**
 * Compute node radius based on current vizMode.
 * In centrality/risk modes, CIs are scaled by their score.
 */
BSMHypergraphRenderer.prototype._computeRadius = function (d) {
  var base = this._nodeRadius(d);

  if (this._vizMode === 'centrality' && this._centralityScores && d.type === 'ci') {
    var score = this._centralityScores[d.uid] || 0;
    // Scale from base to 3x base based on centrality
    return base + score * base * 2;
  }

  if (this._vizMode === 'risk' && this._riskScores && d.type === 'ci') {
    var riskScore = this._riskScores[d.uid] || 0;
    return base + (riskScore / 100) * base * 1.5;
  }

  return base;
};

/**
 * Compute node color based on current vizMode.
 */
BSMHypergraphRenderer.prototype._computeColor = function (d) {
  if (this._vizMode === 'cluster' && this._clusterAssignments && d.type === 'ci') {
    var clusterId = this._clusterAssignments[d.uid];
    if (clusterId != null) {
      return this._clusterPalette[clusterId % this._clusterPalette.length];
    }
  }

  if (this._vizMode === 'risk' && this._riskScores && d.type === 'ci') {
    var score = this._riskScores[d.uid] || 0;
    return this._riskGradient(score);
  }

  return this._nodeColors[d.type] || '#999';
};

// ---------- Analytics Visualization API ----------

/**
 * Set the visualization mode and apply analytics overlays.
 * @param {string} mode - 'type' | 'centrality' | 'cluster' | 'risk'
 */
BSMHypergraphRenderer.prototype.setVizMode = function (mode) {
  this._vizMode = mode;
  this._applyVisualOverlay();
};

/**
 * Supply centrality scores for centrality viz mode.
 * @param {Object} scores - { nodeUid: normalizedScore }
 * @param {string} metric - 'composite' | 'degree' | 'betweenness' | 'eigenvector'
 */
BSMHypergraphRenderer.prototype.setCentralityData = function (scores, metric) {
  this._centralityScores = scores;
  this._centralityMetric = metric || 'composite';
  if (this._vizMode === 'centrality') this._applyVisualOverlay();
};

/**
 * Supply cluster assignments for cluster viz mode.
 * @param {Object} assignments - { nodeUid: clusterId }
 */
BSMHypergraphRenderer.prototype.setClusterData = function (assignments) {
  this._clusterAssignments = assignments;
  if (this._vizMode === 'cluster') this._applyVisualOverlay();
};

/**
 * Supply risk scores for risk viz mode.
 * @param {Object} scores - { nodeUid: score 0-100 }
 */
BSMHypergraphRenderer.prototype.setRiskData = function (scores) {
  this._riskScores = scores;
  if (this._vizMode === 'risk') this._applyVisualOverlay();
};

/**
 * Highlight specific nodes as anomalous (pulse rings).
 * @param {string[]} nodeUids - UIDs of anomalous nodes
 */
BSMHypergraphRenderer.prototype.setAnomalyNodes = function (nodeUids) {
  this._anomalyNodes = new Set(nodeUids || []);
  this._drawAnomalyRings();
};

/**
 * Show directional cascade arrows between node pairs.
 * @param {Array} cascades - [{ source: uid, target: uid, count: N }]
 */
BSMHypergraphRenderer.prototype.setCascadeOverlays = function (cascades) {
  this._cascadeOverlays = cascades || [];
  this._drawCascadeArrows();
};

/**
 * Highlight specific node UIDs (for analytics panel interactions).
 * @param {string[]} nodeUids - UIDs to highlight
 */
BSMHypergraphRenderer.prototype.highlightNodes = function (nodeUids) {
  var highlightSet = new Set(nodeUids || []);
  if (highlightSet.size === 0) {
    this.clearHighlight();
    return;
  }

  this._nodeLayer.selectAll('circle')
    .attr('opacity', function (n) { return highlightSet.has(n.uid) ? 1 : 0.12; })
    .attr('filter', function (n) { return highlightSet.has(n.uid) ? 'url(#glow)' : null; });

  this._labelLayer.selectAll('text')
    .attr('opacity', function (n) { return highlightSet.has(n.uid) ? 1 : 0.05; });

  this._linkLayer.selectAll('line')
    .attr('stroke-opacity', function (l) {
      var sUid = l.source.uid || l.source;
      var tUid = l.target.uid || l.target;
      return highlightSet.has(sUid) && highlightSet.has(tUid) ? 0.5 : 0.02;
    });
};

/**
 * Re-apply visual overlays (color, size) after mode or data changes.
 */
BSMHypergraphRenderer.prototype._applyVisualOverlay = function () {
  var self = this;
  if (!this._currentNodes) return;

  this._currentNodes
    .transition().duration(400)
    .attr('r', function (d) { return self._computeRadius(d); })
    .attr('fill', function (d) { return self._computeColor(d); })
    .attr('stroke', function (d) { return d3.color(self._computeColor(d)).darker(0.5); });

  // Update labels y-offset for new radii
  this._currentLabels
    .transition().duration(400)
    .attr('dy', function (d) { return self._computeRadius(d) + 12; });

  // Update collision force for new radii
  if (this.simulation) {
    this.simulation.force('collision', d3.forceCollide().radius(function (d) {
      return self._computeRadius(d) + 4;
    }));
    this.simulation.alpha(0.15).restart();
  }
};

/**
 * Draw anomaly pulse rings around flagged nodes.
 */
BSMHypergraphRenderer.prototype._drawAnomalyRings = function () {
  if (!this._pulseLayer) return;
  var self = this;
  this._pulseLayer.selectAll('circle').remove();

  if (this._anomalyNodes.size === 0 || !this.currentGraph) return;

  var anomalyData = this.currentGraph.nodes.filter(function (n) {
    return self._anomalyNodes.has(n.uid);
  });

  this._pulseLayer.selectAll('circle')
    .data(anomalyData)
    .enter().append('circle')
    .attr('class', 'anomaly-ring')
    .attr('cx', function (d) { return d.x || 0; })
    .attr('cy', function (d) { return d.y || 0; })
    .attr('r', function (d) { return self._computeRadius(d) + 6; })
    .attr('fill', 'none')
    .attr('stroke', '#ff8a80')
    .attr('stroke-width', 2)
    .attr('stroke-dasharray', '4,3')
    .attr('opacity', 0.7)
    .attr('filter', 'url(#anomaly-pulse)');
};

/**
 * Draw directional arrows for temporal cascades.
 */
BSMHypergraphRenderer.prototype._drawCascadeArrows = function () {
  if (!this._cascadeLayer || !this._currentNodeById) return;
  this._cascadeLayer.selectAll('line').remove();

  if (this._cascadeOverlays.length === 0) return;

  var nodeById = this._currentNodeById;
  var maxCount = 1;
  for (var i = 0; i < this._cascadeOverlays.length; i++) {
    if (this._cascadeOverlays[i].count > maxCount) maxCount = this._cascadeOverlays[i].count;
  }

  var cascadeData = [];
  for (var j = 0; j < this._cascadeOverlays.length; j++) {
    var c = this._cascadeOverlays[j];
    var sNode = nodeById[c.source];
    var tNode = nodeById[c.target];
    if (sNode && tNode) {
      cascadeData.push({
        sourceNode: sNode,
        targetNode: tNode,
        count: c.count,
        width: 1 + (c.count / maxCount) * 3
      });
    }
  }

  this._cascadeLayer.selectAll('line')
    .data(cascadeData)
    .enter().append('line')
    .attr('class', 'cascade-line')
    .attr('x1', function (d) { return d.sourceNode.x || 0; })
    .attr('y1', function (d) { return d.sourceNode.y || 0; })
    .attr('x2', function (d) { return d.targetNode.x || 0; })
    .attr('y2', function (d) { return d.targetNode.y || 0; })
    .attr('stroke', '#ff8a80')
    .attr('stroke-width', function (d) { return d.width; })
    .attr('stroke-opacity', 0.6)
    .attr('marker-end', 'url(#cascade-arrow)');
};

// ---------- Visibility (Filters + Search) ----------

BSMHypergraphRenderer.prototype._isVisible = function (d) {
  if (this._hiddenTypes.has(d.type)) return false;
  if (this._searchTerm) {
    var term = this._searchTerm.toLowerCase();
    var name = (d.name || '').toLowerCase();
    var uid = (d.uid || '').toLowerCase();
    if (name.indexOf(term) === -1 && uid.indexOf(term) === -1) return false;
  }
  return true;
};

BSMHypergraphRenderer.prototype.setSearch = function (term) {
  this._searchTerm = term || '';
  if (this.simulation) this.simulation.alpha(0.1).restart();
};

BSMHypergraphRenderer.prototype.toggleType = function (type) {
  if (this._hiddenTypes.has(type)) {
    this._hiddenTypes.delete(type);
  } else {
    this._hiddenTypes.add(type);
  }
  if (this.simulation) this.simulation.alpha(0.1).restart();
};

BSMHypergraphRenderer.prototype.isTypeVisible = function (type) {
  return !this._hiddenTypes.has(type);
};

// ---------- Force Controls ----------

BSMHypergraphRenderer.prototype.setChargeStrength = function (val) {
  if (!this.simulation) return;
  this.simulation.force('charge').strength(val);
  this.simulation.alpha(0.3).restart();
};

BSMHypergraphRenderer.prototype.setLinkDistance = function (val) {
  if (!this.simulation) return;
  this.simulation.force('link').distance(val);
  this.simulation.alpha(0.3).restart();
};

// ---------- Drag Handlers ----------

BSMHypergraphRenderer.prototype._dragStart = function (event, d) {
  if (!event.active) this.simulation.alphaTarget(0.3).restart();
  d.fx = d.x;
  d.fy = d.y;
};

BSMHypergraphRenderer.prototype._dragMove = function (event, d) {
  d.fx = event.x;
  d.fy = event.y;
};

BSMHypergraphRenderer.prototype._dragEnd = function (event, d) {
  if (!event.active) this.simulation.alphaTarget(0);
  d.fx = null;
  d.fy = null;
};

// ---------- Tooltip ----------

BSMHypergraphRenderer.prototype._showTooltip = function (event, d) {
  var lines = ['<strong>' + d.name + '</strong>'];
  lines.push('<span class="hg-tooltip-type">' + d.type + '</span>');

  if (d.type === 'ci') {
    if (d.className) lines.push('Class: ' + d.className);
    if (d.ipAddress) lines.push('IP: ' + d.ipAddress);
    if (d.role) lines.push('Role: ' + d.role);
  } else if (d.type === 'change') {
    if (d.risk) lines.push('Risk: ' + d.risk);
    if (d.changeType) lines.push('Type: ' + d.changeType);
    if (d.impact) lines.push('Impact: ' + d.impact);
    if (d.region) lines.push('Region: ' + d.region);
  }

  // Degree (number of hyperedges containing this node)
  if (this.currentGraph && this.currentGraph.incidence[d.uid]) {
    lines.push('Degree: ' + this.currentGraph.incidence[d.uid].size);
  }

  // Analytics data in tooltip
  if (this._centralityScores && this._centralityScores[d.uid] != null) {
    lines.push('Centrality: ' + (this._centralityScores[d.uid] * 100).toFixed(1) + '%');
  }
  if (this._riskScores && this._riskScores[d.uid] != null) {
    lines.push('Risk: ' + Math.round(this._riskScores[d.uid]) + '/100');
  }
  if (this._clusterAssignments && this._clusterAssignments[d.uid] != null) {
    lines.push('Cluster: #' + this._clusterAssignments[d.uid]);
  }
  if (this._anomalyNodes.has(d.uid)) {
    lines.push('<span style="color:#ff8a80">&#9888; Anomaly detected</span>');
  }

  this._tooltip
    .html(lines.join('<br>'))
    .style('left', (event.pageX + 12) + 'px')
    .style('top', (event.pageY - 12) + 'px')
    .transition().duration(150).style('opacity', 1);
};

BSMHypergraphRenderer.prototype._hideTooltip = function () {
  this._tooltip.transition().duration(200).style('opacity', 0);
};

// ---------- Click ----------

BSMHypergraphRenderer.prototype._handleNodeClick = function (event, d) {
  // Highlight connected nodes
  this._highlightConnected(d);
  if (this._onNodeClick) this._onNodeClick(d);
};

BSMHypergraphRenderer.prototype._highlightConnected = function (d) {
  var connectedSet = new Set();
  connectedSet.add(d.uid);

  if (this.currentGraph && this.currentGraph.incidence[d.uid]) {
    var edgeUids = Array.from(this.currentGraph.incidence[d.uid]);
    for (var i = 0; i < this.currentGraph.edges.length; i++) {
      var edge = this.currentGraph.edges[i];
      if (edgeUids.indexOf(edge.uid) !== -1) {
        for (var j = 0; j < edge.elements.length; j++) {
          connectedSet.add(edge.elements[j]);
        }
      }
    }
  }

  this._nodeLayer.selectAll('circle')
    .attr('opacity', function (n) { return connectedSet.has(n.uid) ? 1 : 0.15; })
    .attr('filter', function (n) { return n.uid === d.uid ? 'url(#glow)' : null; });

  this._labelLayer.selectAll('text')
    .attr('opacity', function (n) { return connectedSet.has(n.uid) ? 1 : 0.1; });

  this._linkLayer.selectAll('line')
    .attr('stroke-opacity', function (l) {
      return connectedSet.has(l.source.uid || l.source) && connectedSet.has(l.target.uid || l.target) ? 0.4 : 0.03;
    });
};

BSMHypergraphRenderer.prototype.clearHighlight = function () {
  this._nodeLayer.selectAll('circle').attr('opacity', 1).attr('filter', null);
  this._labelLayer.selectAll('text').attr('opacity', 1);
  this._linkLayer.selectAll('line').attr('stroke-opacity', 0.15);
};

/**
 * Clear all analytics overlays (cascades, anomalies, highlights).
 */
BSMHypergraphRenderer.prototype.clearAnalyticsOverlays = function () {
  this.clearHighlight();
  this._cascadeOverlays = [];
  this._anomalyNodes = new Set();
  if (this._cascadeLayer) this._cascadeLayer.selectAll('line').remove();
  if (this._pulseLayer) this._pulseLayer.selectAll('circle').remove();
};

// ---------- Resize ----------

BSMHypergraphRenderer.prototype.resize = function () {
  if (this.currentGraph) this.render(this.currentGraph);
};

// ---------- Destroy ----------

BSMHypergraphRenderer.prototype.destroy = function () {
  if (this.simulation) this.simulation.stop();
  d3.select(this.containerSelector).selectAll('*').remove();
};

/* ── AnalyticsEngine ── */
/**
 * AnalyticsEngine — Advanced BSM Hypergraph Analytics
 *
 * Provides centrality analysis, temporal cascade detection, weighted
 * co-occurrence, anomaly detection, community detection, change impact
 * prediction, and incident correlation on top of HypergraphCore output.
 *
 * All algorithms are implemented in pure ES5 JavaScript with no external
 * dependencies.  Scores are normalized 0-1 where applicable.
 *
 * Usage:
 *   var engine = new AnalyticsEngine();
 *   var scores = engine.centrality(graph);
 *   var cascades = engine.temporalCascades(graph, rawData, 7);
 */

function AnalyticsEngine() {}

// ===================================================================
//  Internal helpers
// ===================================================================

/**
 * Build a lookup map from node uid to node object.
 * @private
 */
AnalyticsEngine.prototype._nodeMap = function (graph) {
  var map = {};
  for (var i = 0; i < graph.nodes.length; i++) {
    map[graph.nodes[i].uid] = graph.nodes[i];
  }
  return map;
};

/**
 * Build a lookup map from edge uid to edge object.
 * @private
 */
AnalyticsEngine.prototype._edgeMap = function (graph) {
  var map = {};
  for (var i = 0; i < graph.edges.length; i++) {
    map[graph.edges[i].uid] = graph.edges[i];
  }
  return map;
};

/**
 * Return an array of node uids whose type === 'ci'.
 * @private
 */
AnalyticsEngine.prototype._ciNodes = function (graph) {
  var result = [];
  for (var i = 0; i < graph.nodes.length; i++) {
    if (graph.nodes[i].type === 'ci') {
      result.push(graph.nodes[i].uid);
    }
  }
  return result;
};

/**
 * Return the maximum degree across all nodes in the incidence map.
 * @private
 */
AnalyticsEngine.prototype._maxDegree = function (incidence) {
  var max = 0;
  var keys = Object.keys(incidence);
  for (var i = 0; i < keys.length; i++) {
    var size = incidence[keys[i]].size;
    if (size > max) max = size;
  }
  return max;
};

/**
 * Compute the risk multiplier for a given risk string.
 * @private
 */
AnalyticsEngine.prototype._riskWeight = function (risk) {
  if (risk === 'Critical') return 4;
  if (risk === 'High') return 3;
  if (risk === 'Medium') return 2;
  return 1; // Low or unrecognised
};

/**
 * Parse an ISO date string to epoch milliseconds.
 * Falls back to 0 on failure.
 * @private
 */
AnalyticsEngine.prototype._parseDate = function (str) {
  if (!str) return 0;
  var d = new Date(str);
  return isNaN(d.getTime()) ? 0 : d.getTime();
};

/**
 * Compute sorted canonical pair key for two uids.
 * @private
 */
AnalyticsEngine.prototype._pairKey = function (a, b) {
  return a < b ? a + '|' + b : b + '|' + a;
};

/**
 * Normalize a plain-object score map in place so that max value = 1.
 * Returns the map for convenience.
 * @private
 */
AnalyticsEngine.prototype._normalize = function (scores) {
  var keys = Object.keys(scores);
  var max = 0;
  var i;
  for (i = 0; i < keys.length; i++) {
    if (scores[keys[i]] > max) max = scores[keys[i]];
  }
  if (max > 0) {
    for (i = 0; i < keys.length; i++) {
      scores[keys[i]] = scores[keys[i]] / max;
    }
  }
  return scores;
};

/**
 * Build a weighted projected adjacency matrix (H x H^T) for CI-type nodes.
 * Returns { nodes: [uid, ...], matrix: { uid: { uid: weight } } }.
 * Weight = number of shared hyperedges.
 * @private
 */
AnalyticsEngine.prototype._projectedAdjacency = function (graph) {
  var ciUids = this._ciNodes(graph);
  var ciSet = {};
  var i, j;
  for (i = 0; i < ciUids.length; i++) {
    ciSet[ciUids[i]] = true;
  }

  // For each edge, collect CI members
  var matrix = {};
  for (i = 0; i < ciUids.length; i++) {
    matrix[ciUids[i]] = {};
  }

  for (i = 0; i < graph.edges.length; i++) {
    var members = graph.edges[i].elements;
    // Filter to CI nodes only
    var ciMembers = [];
    for (j = 0; j < members.length; j++) {
      if (ciSet[members[j]]) ciMembers.push(members[j]);
    }
    // All pairs
    for (var a = 0; a < ciMembers.length; a++) {
      for (var b = a + 1; b < ciMembers.length; b++) {
        var u = ciMembers[a];
        var v = ciMembers[b];
        matrix[u][v] = (matrix[u][v] || 0) + 1;
        matrix[v][u] = (matrix[v][u] || 0) + 1;
      }
    }
  }

  return { nodes: ciUids, matrix: matrix };
};

/**
 * Build a flat change list with timestamps from rawData.taskCiRecords.
 * Groups flat task_ci rows by task.number into per-change entries.
 * Each entry: { number, createdAt (ms), risk, changeType, impact,
 *               region, assignmentGroup, ciUids: [...] }
 * @private
 */
AnalyticsEngine.prototype._changeList = function (rawData) {
  var records = rawData.taskCiRecords;
  if (!records || records.length === 0) return [];

  // Group task_ci records by change number
  var changeMap = {};
  for (var i = 0; i < records.length; i++) {
    var rec = records[i];
    var num = rec['task.number'];
    if (!changeMap[num]) {
      changeMap[num] = {
        number: num,
        createdAt: this._parseDate(rec['task.sys_created_on']),
        risk: rec['task.risk'] || 'Low',
        changeType: rec['task.type'] || 'Standard',
        impact: rec['task.impact'] || '3 - Low',
        region: rec['task.u_impact_region'] || '',
        assignmentGroup: rec['task.assignment_group'] || '',
        ciUids: []
      };
    }
    changeMap[num].ciUids.push('ci:' + rec['ci_item.sys_id']);
  }

  var list = [];
  var nums = Object.keys(changeMap);
  for (var j = 0; j < nums.length; j++) {
    list.push(changeMap[nums[j]]);
  }
  // Sort by createdAt ascending
  list.sort(function (a, b) { return a.createdAt - b.createdAt; });
  return list;
};

// ===================================================================
//  1. Centrality Analysis
// ===================================================================

/**
 * Compute four centrality measures for every node in the graph.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @returns {Object} { degree, betweenness, eigenvector, composite }
 *   Each value is { nodeUid: score } normalized 0-1.
 */
AnalyticsEngine.prototype.centrality = function (graph) {
  if (!graph || !graph.nodes || graph.nodes.length === 0) {
    return { degree: {}, betweenness: {}, eigenvector: {}, composite: {} };
  }

  var degreeScores = this._degreeCentrality(graph);
  var betweennessScores = this._betweennessCentrality(graph);
  var eigenvectorScores = this._eigenvectorCentrality(graph);

  // Composite
  var composite = {};
  var keys = Object.keys(degreeScores);
  for (var i = 0; i < keys.length; i++) {
    var uid = keys[i];
    composite[uid] =
      0.3 * (degreeScores[uid] || 0) +
      0.3 * (betweennessScores[uid] || 0) +
      0.4 * (eigenvectorScores[uid] || 0);
  }
  this._normalize(composite);

  return {
    degree: degreeScores,
    betweenness: betweennessScores,
    eigenvector: eigenvectorScores,
    composite: composite
  };
};

/**
 * Degree centrality: node degree / max degree.
 * @private
 */
AnalyticsEngine.prototype._degreeCentrality = function (graph) {
  var scores = {};
  var maxDeg = this._maxDegree(graph.incidence);
  if (maxDeg === 0) maxDeg = 1;

  for (var i = 0; i < graph.nodes.length; i++) {
    var uid = graph.nodes[i].uid;
    var deg = graph.incidence[uid] ? graph.incidence[uid].size : 0;
    scores[uid] = deg / maxDeg;
  }
  return scores;
};

/**
 * Betweenness centrality (sampled approximation for hypergraphs).
 *
 * For each sampled pair (s, t) of CI-type nodes, find the shortest
 * hyperedge-hop path via BFS on the bipartite node-edge graph and
 * credit intermediate CI nodes.
 * @private
 */
AnalyticsEngine.prototype._betweennessCentrality = function (graph) {
  var ciUids = this._ciNodes(graph);
  var scores = {};
  var i;
  for (i = 0; i < graph.nodes.length; i++) {
    scores[graph.nodes[i].uid] = 0;
  }

  if (ciUids.length < 2) {
    return this._normalize(scores);
  }

  // Build adjacency: node -> Set(node) through shared edges
  var adj = {};
  for (i = 0; i < graph.nodes.length; i++) {
    adj[graph.nodes[i].uid] = {};
  }
  // For each edge, connect all member pairs
  var edgeMap = this._edgeMap(graph);
  for (i = 0; i < graph.edges.length; i++) {
    var members = graph.edges[i].elements;
    for (var a = 0; a < members.length; a++) {
      for (var b = a + 1; b < members.length; b++) {
        if (!adj[members[a]]) adj[members[a]] = {};
        if (!adj[members[b]]) adj[members[b]] = {};
        adj[members[a]][members[b]] = true;
        adj[members[b]][members[a]] = true;
      }
    }
  }

  // Sample up to 200 random (s, t) pairs of CI nodes
  var sampleCount = Math.min(200, ciUids.length * (ciUids.length - 1) / 2);
  var sampled = {};
  var pairsProcessed = 0;
  var attempts = 0;
  var maxAttempts = sampleCount * 10;

  // Simple deterministic shuffle using index mixing
  while (pairsProcessed < sampleCount && attempts < maxAttempts) {
    var si = Math.floor((attempts * 7 + 13) % ciUids.length);
    var ti = Math.floor((attempts * 11 + 23) % ciUids.length);
    attempts++;
    if (si === ti) continue;
    var pKey = si < ti ? si + ':' + ti : ti + ':' + si;
    if (sampled[pKey]) continue;
    sampled[pKey] = true;
    pairsProcessed++;

    var source = ciUids[si];
    var target = ciUids[ti];

    // BFS from source to target
    var path = this._bfsPath(adj, source, target);
    if (path && path.length > 2) {
      // Credit intermediate nodes (exclude source and target)
      for (var p = 1; p < path.length - 1; p++) {
        scores[path[p]] = (scores[path[p]] || 0) + 1;
      }
    }
  }

  return this._normalize(scores);
};

/**
 * BFS shortest path between source and target in an adjacency dict.
 * Returns array of node uids forming the path, or null if unreachable.
 * @private
 */
AnalyticsEngine.prototype._bfsPath = function (adj, source, target) {
  if (source === target) return [source];
  var queue = [source];
  var visited = {};
  var parent = {};
  visited[source] = true;

  while (queue.length > 0) {
    var current = queue.shift();
    var neighbors = adj[current];
    if (!neighbors) continue;
    var nKeys = Object.keys(neighbors);
    for (var i = 0; i < nKeys.length; i++) {
      var nb = nKeys[i];
      if (visited[nb]) continue;
      visited[nb] = true;
      parent[nb] = current;
      if (nb === target) {
        // Reconstruct path
        var path = [target];
        var node = target;
        while (parent[node] !== undefined) {
          node = parent[node];
          path.unshift(node);
        }
        return path;
      }
      queue.push(nb);
    }
  }
  return null;
};

/**
 * Eigenvector centrality via power iteration on the projected
 * adjacency matrix A = H x H^T.
 * @private
 */
AnalyticsEngine.prototype._eigenvectorCentrality = function (graph) {
  var proj = this._projectedAdjacency(graph);
  var nodes = proj.nodes;
  var matrix = proj.matrix;
  var n = nodes.length;

  if (n === 0) {
    var empty = {};
    for (var z = 0; z < graph.nodes.length; z++) {
      empty[graph.nodes[z].uid] = 0;
    }
    return empty;
  }

  // Index map for faster lookup
  var idx = {};
  var i, j;
  for (i = 0; i < n; i++) {
    idx[nodes[i]] = i;
  }

  // Start with uniform vector
  var vec = new Array(n);
  var initVal = 1.0 / n;
  for (i = 0; i < n; i++) {
    vec[i] = initVal;
  }

  // Power iteration (20 iterations)
  for (var iter = 0; iter < 20; iter++) {
    var newVec = new Array(n);
    for (i = 0; i < n; i++) {
      newVec[i] = 0;
    }

    for (i = 0; i < n; i++) {
      var row = matrix[nodes[i]];
      var rowKeys = Object.keys(row);
      for (j = 0; j < rowKeys.length; j++) {
        var colIdx = idx[rowKeys[j]];
        if (colIdx !== undefined) {
          newVec[i] += row[rowKeys[j]] * vec[colIdx];
        }
      }
    }

    // Normalize by L2 norm
    var norm = 0;
    for (i = 0; i < n; i++) {
      norm += newVec[i] * newVec[i];
    }
    norm = Math.sqrt(norm);
    if (norm > 0) {
      for (i = 0; i < n; i++) {
        newVec[i] = newVec[i] / norm;
      }
    }
    vec = newVec;
  }

  // Build scores for all graph nodes (non-CI nodes get 0)
  var scores = {};
  for (i = 0; i < graph.nodes.length; i++) {
    scores[graph.nodes[i].uid] = 0;
  }
  for (i = 0; i < n; i++) {
    scores[nodes[i]] = Math.abs(vec[i]);
  }

  return this._normalize(scores);
};

/**
 * Return top N nodes by composite centrality with explanations.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {number} [topN=10] - Number of top nodes to return
 * @returns {Array<{uid, name, type, composite, degree, betweenness, eigenvector, reason}>}
 */
AnalyticsEngine.prototype.criticalNodes = function (graph, topN) {
  topN = topN || 10;

  if (!graph || !graph.nodes || graph.nodes.length === 0) {
    return [];
  }

  var cent = this.centrality(graph);
  var nodeMap = this._nodeMap(graph);
  var keys = Object.keys(cent.composite);

  var entries = [];
  for (var i = 0; i < keys.length; i++) {
    var uid = keys[i];
    var node = nodeMap[uid];
    var d = cent.degree[uid] || 0;
    var b = cent.betweenness[uid] || 0;
    var e = cent.eigenvector[uid] || 0;
    var c = cent.composite[uid] || 0;

    // Determine dominant reason
    var reason = 'general importance';
    var maxMetric = Math.max(d, b, e);
    if (maxMetric > 0) {
      if (b === maxMetric) {
        reason = 'bridge — lies on many shortest paths between CIs';
      } else if (d === maxMetric) {
        reason = 'hub — participates in many change requests';
      } else {
        reason = 'connected to important nodes — high influence via neighbors';
      }
    }

    entries.push({
      uid: uid,
      name: node ? node.name : uid,
      type: node ? node.type : 'unknown',
      composite: Math.round(c * 10000) / 10000,
      degree: Math.round(d * 10000) / 10000,
      betweenness: Math.round(b * 10000) / 10000,
      eigenvector: Math.round(e * 10000) / 10000,
      reason: reason
    });
  }

  entries.sort(function (a, b) { return b.composite - a.composite; });
  return entries.slice(0, topN);
};

// ===================================================================
//  2. Temporal Cascade Analysis
// ===================================================================

/**
 * Analyse time-lagged change patterns between CI pairs.
 *
 * For each pair of CIs, count how often a change to CI-A is followed
 * by a change to CI-B within windowDays.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {Object} rawData - Output of ITILDataSimulator.generate() (changes must include createdAt)
 * @param {number} [windowDays=7] - Time window in days
 * @returns {Array<{source, target, count, avgLagDays, direction}>}
 */
AnalyticsEngine.prototype.temporalCascades = function (graph, rawData, windowDays) {
  windowDays = windowDays || 7;
  var windowMs = windowDays * 24 * 60 * 60 * 1000;

  if (!rawData || !rawData.taskCiRecords) return [];

  var changeList = this._changeList(rawData);

  // Build CI -> sorted list of change timestamps
  var ciChanges = {}; // ciUid -> [{ time, number }]
  var i, j;
  for (i = 0; i < changeList.length; i++) {
    var chg = changeList[i];
    for (j = 0; j < chg.ciUids.length; j++) {
      var ciUid = chg.ciUids[j];
      if (!ciChanges[ciUid]) ciChanges[ciUid] = [];
      ciChanges[ciUid].push({ time: chg.createdAt, number: chg.number });
    }
  }

  // Sort each CI's changes by time
  var ciUids = Object.keys(ciChanges);
  for (i = 0; i < ciUids.length; i++) {
    ciChanges[ciUids[i]].sort(function (a, b) { return a.time - b.time; });
  }

  // Count directed cascades: A changed then B changed within window
  var cascadeMap = {}; // "A|B" -> { count, totalLag }
  for (i = 0; i < ciUids.length; i++) {
    var uidA = ciUids[i];
    var changesA = ciChanges[uidA];
    for (j = 0; j < ciUids.length; j++) {
      if (i === j) continue;
      var uidB = ciUids[j];
      var changesB = ciChanges[uidB];
      var dirKey = uidA + '|' + uidB;

      for (var ca = 0; ca < changesA.length; ca++) {
        var tA = changesA[ca].time;
        if (tA === 0) continue;
        for (var cb = 0; cb < changesB.length; cb++) {
          var tB = changesB[cb].time;
          if (tB === 0) continue;
          var lag = tB - tA;
          if (lag > 0 && lag <= windowMs) {
            if (!cascadeMap[dirKey]) {
              cascadeMap[dirKey] = { count: 0, totalLag: 0 };
            }
            cascadeMap[dirKey].count++;
            cascadeMap[dirKey].totalLag += lag;
          }
        }
      }
    }
  }

  // Merge directed pairs into bidirectional result
  var pairResults = {};
  var dirKeys = Object.keys(cascadeMap);
  for (i = 0; i < dirKeys.length; i++) {
    var parts = dirKeys[i].split('|');
    var a = parts[0];
    var b = parts[1];
    var canonKey = this._pairKey(a, b);
    if (!pairResults[canonKey]) {
      pairResults[canonKey] = { a: a, b: b, aToB: 0, bToA: 0, totalLag: 0, totalCount: 0 };
    }
    var entry = cascadeMap[dirKeys[i]];
    if (a < b) {
      pairResults[canonKey].aToB += entry.count;
    } else {
      pairResults[canonKey].bToA += entry.count;
    }
    pairResults[canonKey].totalLag += entry.totalLag;
    pairResults[canonKey].totalCount += entry.count;
  }

  // Build output
  var results = [];
  var pairKeys = Object.keys(pairResults);
  for (i = 0; i < pairKeys.length; i++) {
    var pr = pairResults[pairKeys[i]];
    var totalCount = pr.aToB + pr.bToA;
    if (totalCount === 0) continue;
    var avgLagMs = (pr.totalLag / totalCount);
    var avgLagDays = avgLagMs / (24 * 60 * 60 * 1000);

    var direction;
    if (pr.aToB > 0 && pr.bToA > 0) {
      direction = 'bidirectional';
    } else if (pr.aToB > 0) {
      direction = 'A\u2192B';
    } else {
      direction = 'B\u2192A';
    }

    results.push({
      source: pr.a,
      target: pr.b,
      count: totalCount,
      avgLagDays: Math.round(avgLagDays * 100) / 100,
      direction: direction
    });
  }

  results.sort(function (x, y) { return y.count - x.count; });
  return results.slice(0, 30);
};

/**
 * Compute per-CI change velocity (changes per week) over the 90-day window.
 *
 * @param {Object} rawData - Output of ITILDataSimulator.generate()
 * @returns {Object} { nodeUid: { weeks: [count,...], avg, max, trend } }
 */
AnalyticsEngine.prototype.changeVelocity = function (rawData) {
  if (!rawData || !rawData.taskCiRecords) return {};

  var changeList = this._changeList(rawData);
  if (changeList.length === 0) return {};

  // Determine time range
  var minTime = Infinity;
  var maxTime = 0;
  var i, j;
  for (i = 0; i < changeList.length; i++) {
    var t = changeList[i].createdAt;
    if (t > 0 && t < minTime) minTime = t;
    if (t > maxTime) maxTime = t;
  }
  if (minTime === Infinity || maxTime === 0) return {};

  var weekMs = 7 * 24 * 60 * 60 * 1000;
  var totalWeeks = Math.ceil((maxTime - minTime) / weekMs);
  if (totalWeeks < 1) totalWeeks = 1;

  // Accumulate per-CI weekly counts
  var ciWeeks = {}; // ciUid -> [weekCounts]
  for (i = 0; i < changeList.length; i++) {
    var chg = changeList[i];
    if (chg.createdAt === 0) continue;
    var weekIdx = Math.min(Math.floor((chg.createdAt - minTime) / weekMs), totalWeeks - 1);
    for (j = 0; j < chg.ciUids.length; j++) {
      var ciUid = chg.ciUids[j];
      if (!ciWeeks[ciUid]) {
        ciWeeks[ciUid] = new Array(totalWeeks);
        for (var w = 0; w < totalWeeks; w++) {
          ciWeeks[ciUid][w] = 0;
        }
      }
      ciWeeks[ciUid][weekIdx]++;
    }
  }

  // Build results — only CIs with 2+ changes total
  var result = {};
  var ciUids = Object.keys(ciWeeks);
  for (i = 0; i < ciUids.length; i++) {
    var weeks = ciWeeks[ciUids[i]];
    var total = 0;
    var max = 0;
    for (j = 0; j < weeks.length; j++) {
      total += weeks[j];
      if (weeks[j] > max) max = weeks[j];
    }
    if (total < 2) continue;

    var avg = total / weeks.length;

    // Trend: compare first half avg to second half avg
    var halfLen = Math.floor(weeks.length / 2);
    var firstHalf = 0;
    var secondHalf = 0;
    if (halfLen > 0) {
      for (j = 0; j < halfLen; j++) {
        firstHalf += weeks[j];
      }
      for (j = halfLen; j < weeks.length; j++) {
        secondHalf += weeks[j];
      }
      firstHalf = firstHalf / halfLen;
      secondHalf = secondHalf / (weeks.length - halfLen);
    }

    var trend = 'stable';
    if (halfLen > 0) {
      var diff = secondHalf - firstHalf;
      var baseline = Math.max(firstHalf, 0.1);
      if (diff / baseline > 0.25) {
        trend = 'increasing';
      } else if (diff / baseline < -0.25) {
        trend = 'decreasing';
      }
    }

    result[ciUids[i]] = {
      weeks: weeks,
      avg: Math.round(avg * 100) / 100,
      max: max,
      trend: trend
    };
  }

  return result;
};

// ===================================================================
//  3. Weighted Co-occurrence
// ===================================================================

/**
 * Compute weighted co-occurrence metrics for CI pairs.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {Object} rawData - Output of ITILDataSimulator.generate()
 * @param {number} [topN=30] - Number of top pairs to return
 * @returns {Array<{a, b, rawCount, riskWeighted, recencyWeighted, diversityWeighted, jaccard, composite}>}
 */
AnalyticsEngine.prototype.weightedCooccurrence = function (graph, rawData, topN) {
  topN = topN || 30;

  if (!graph || !graph.edges || graph.edges.length === 0) return [];

  var changeList = this._changeList(rawData || { taskCiRecords: [] });

  // Determine "now" as max timestamp for recency calc
  var now = 0;
  var i, j;
  for (i = 0; i < changeList.length; i++) {
    if (changeList[i].createdAt > now) now = changeList[i].createdAt;
  }
  if (now === 0) now = Date.now();

  var halfLifeMs = 30 * 24 * 60 * 60 * 1000; // 30 days
  var ln2 = Math.log(2);

  // Build change lookup by edge uid
  var changeByNumber = {};
  for (i = 0; i < changeList.length; i++) {
    changeByNumber[changeList[i].number] = changeList[i];
  }

  // CI node set
  var ciSet = {};
  var ciUids = this._ciNodes(graph);
  for (i = 0; i < ciUids.length; i++) {
    ciSet[ciUids[i]] = true;
  }

  // Track per-CI edges and per-pair metrics
  var ciEdges = {}; // ciUid -> Set(edgeUid)
  var pairMap = {}; // pairKey -> { rawCount, riskWeighted, recencyWeighted, groups (Set) }

  for (i = 0; i < graph.edges.length; i++) {
    var edge = graph.edges[i];
    var ciMembers = [];
    for (j = 0; j < edge.elements.length; j++) {
      if (ciSet[edge.elements[j]]) {
        ciMembers.push(edge.elements[j]);
        if (!ciEdges[edge.elements[j]]) ciEdges[edge.elements[j]] = {};
        ciEdges[edge.elements[j]][edge.uid] = true;
      }
    }

    // Look up change metadata
    var chgNumber = edge.number || '';
    var chgData = changeByNumber[chgNumber];
    var riskW = this._riskWeight(edge.risk || 'Low');
    var age = (chgData && chgData.createdAt > 0) ? (now - chgData.createdAt) : 0;
    var recencyW = Math.exp(-ln2 * age / halfLifeMs);
    var groupName = edge.assignmentGroup || (chgData ? chgData.assignmentGroup : '');

    // All CI pairs in this edge
    for (var a = 0; a < ciMembers.length; a++) {
      for (var b = a + 1; b < ciMembers.length; b++) {
        var pk = this._pairKey(ciMembers[a], ciMembers[b]);
        if (!pairMap[pk]) {
          pairMap[pk] = {
            a: ciMembers[a] < ciMembers[b] ? ciMembers[a] : ciMembers[b],
            b: ciMembers[a] < ciMembers[b] ? ciMembers[b] : ciMembers[a],
            rawCount: 0,
            riskWeighted: 0,
            recencyWeighted: 0,
            groups: {}
          };
        }
        pairMap[pk].rawCount++;
        pairMap[pk].riskWeighted += riskW;
        pairMap[pk].recencyWeighted += recencyW;
        if (groupName) pairMap[pk].groups[groupName] = true;
      }
    }
  }

  // Build output with Jaccard and diversity
  var results = [];
  var pairKeys = Object.keys(pairMap);
  for (i = 0; i < pairKeys.length; i++) {
    var pm = pairMap[pairKeys[i]];
    var edgesA = ciEdges[pm.a] || {};
    var edgesB = ciEdges[pm.b] || {};
    var keysA = Object.keys(edgesA);
    var keysB = Object.keys(edgesB);

    // Jaccard: |intersection| / |union|
    var intersection = 0;
    for (j = 0; j < keysA.length; j++) {
      if (edgesB[keysA[j]]) intersection++;
    }
    // Union = |A| + |B| - |intersection|
    var union = keysA.length + keysB.length - intersection;
    var jaccard = union > 0 ? intersection / union : 0;

    var diversityWeighted = Object.keys(pm.groups).length;

    results.push({
      a: pm.a,
      b: pm.b,
      rawCount: pm.rawCount,
      riskWeighted: Math.round(pm.riskWeighted * 100) / 100,
      recencyWeighted: Math.round(pm.recencyWeighted * 100) / 100,
      diversityWeighted: diversityWeighted,
      jaccard: Math.round(jaccard * 10000) / 10000,
      composite: 0 // placeholder, normalised below
    });
  }

  if (results.length === 0) return [];

  // Normalise each metric to 0-1 and compute composite
  var maxRaw = 0, maxRisk = 0, maxRecency = 0, maxDiv = 0, maxJac = 0;
  for (i = 0; i < results.length; i++) {
    if (results[i].rawCount > maxRaw) maxRaw = results[i].rawCount;
    if (results[i].riskWeighted > maxRisk) maxRisk = results[i].riskWeighted;
    if (results[i].recencyWeighted > maxRecency) maxRecency = results[i].recencyWeighted;
    if (results[i].diversityWeighted > maxDiv) maxDiv = results[i].diversityWeighted;
    if (results[i].jaccard > maxJac) maxJac = results[i].jaccard;
  }

  for (i = 0; i < results.length; i++) {
    var r = results[i];
    var nRaw = maxRaw > 0 ? r.rawCount / maxRaw : 0;
    var nRisk = maxRisk > 0 ? r.riskWeighted / maxRisk : 0;
    var nRecency = maxRecency > 0 ? r.recencyWeighted / maxRecency : 0;
    var nDiv = maxDiv > 0 ? r.diversityWeighted / maxDiv : 0;
    var nJac = maxJac > 0 ? r.jaccard / maxJac : 0;
    r.composite = Math.round((0.25 * nRaw + 0.25 * nRisk + 0.2 * nRecency + 0.15 * nDiv + 0.15 * nJac) * 10000) / 10000;
  }

  results.sort(function (x, y) { return y.composite - x.composite; });
  return results.slice(0, topN);
};

// ===================================================================
//  4. Anomaly Detection
// ===================================================================

/**
 * Detect structural and statistical anomalies in the change graph.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {Object} rawData - Output of ITILDataSimulator.generate()
 * @returns {Object} { unexpectedPairs, orphans, overCoupled, underCoupled }
 */
AnalyticsEngine.prototype.detectAnomalies = function (graph, rawData) {
  if (!graph || !graph.nodes) {
    return { unexpectedPairs: [], orphans: [], overCoupled: [], underCoupled: [] };
  }

  var nodeMap = this._nodeMap(graph);
  var ciUids = this._ciNodes(graph);
  var ciSet = {};
  var i, j;
  for (i = 0; i < ciUids.length; i++) {
    ciSet[ciUids[i]] = true;
  }

  // --- Orphans ---
  var orphans = [];
  for (i = 0; i < ciUids.length; i++) {
    var uid = ciUids[i];
    var deg = graph.incidence[uid] ? graph.incidence[uid].size : 0;
    if (deg <= 1) {
      var node = nodeMap[uid];
      orphans.push({
        uid: uid,
        name: node ? node.name : uid,
        degree: deg,
        reason: deg === 0 ? 'no changes reference this CI' : 'only 1 change references this CI'
      });
    }
  }

  // --- Count class frequencies and pair co-occurrences ---
  var classCount = {}; // className -> number of edges that include that class
  var totalEdges = graph.edges.length;
  var pairCooccur = {}; // pairKey -> count
  var ciEdgeCount = {}; // ciUid -> Set(edgeUid)

  for (i = 0; i < graph.edges.length; i++) {
    var edge = graph.edges[i];
    var ciMembers = [];
    var classesInEdge = {};
    for (j = 0; j < edge.elements.length; j++) {
      var el = edge.elements[j];
      if (ciSet[el]) {
        ciMembers.push(el);
        var n = nodeMap[el];
        var cls = n ? n.className : 'unknown';
        classesInEdge[cls] = true;
        if (!ciEdgeCount[el]) ciEdgeCount[el] = {};
        ciEdgeCount[el][edge.uid] = true;
      }
    }
    var classNames = Object.keys(classesInEdge);
    for (j = 0; j < classNames.length; j++) {
      classCount[classNames[j]] = (classCount[classNames[j]] || 0) + 1;
    }
    for (var a = 0; a < ciMembers.length; a++) {
      for (var b = a + 1; b < ciMembers.length; b++) {
        var pk = this._pairKey(ciMembers[a], ciMembers[b]);
        pairCooccur[pk] = (pairCooccur[pk] || 0) + 1;
      }
    }
  }

  // --- Unexpected pairs ---
  var unexpectedPairs = [];
  var pairKeys = Object.keys(pairCooccur);
  for (i = 0; i < pairKeys.length; i++) {
    var parts = pairKeys[i].split('|');
    var nodeA = nodeMap[parts[0]];
    var nodeB = nodeMap[parts[1]];
    if (!nodeA || !nodeB) continue;

    var classA = nodeA.className || 'unknown';
    var classB = nodeB.className || 'unknown';
    var freqA = (classCount[classA] || 0) / Math.max(totalEdges, 1);
    var freqB = (classCount[classB] || 0) / Math.max(totalEdges, 1);
    var expected = freqA * freqB * totalEdges;
    var actual = pairCooccur[pairKeys[i]];

    if (expected > 0 && actual > 2 * expected) {
      unexpectedPairs.push({
        a: parts[0],
        b: parts[1],
        nameA: nodeA.name,
        nameB: nodeB.name,
        classA: classA,
        classB: classB,
        actual: actual,
        expected: Math.round(expected * 100) / 100,
        ratio: Math.round((actual / expected) * 100) / 100
      });
    }
  }
  unexpectedPairs.sort(function (x, y) { return y.ratio - x.ratio; });

  // --- Over-coupled (Jaccard > 0.5) ---
  var overCoupled = [];
  for (i = 0; i < pairKeys.length; i++) {
    var partsOC = pairKeys[i].split('|');
    var edgesA = ciEdgeCount[partsOC[0]] || {};
    var edgesB = ciEdgeCount[partsOC[1]] || {};
    var keysA = Object.keys(edgesA);
    var keysB = Object.keys(edgesB);
    var inter = 0;
    for (j = 0; j < keysA.length; j++) {
      if (edgesB[keysA[j]]) inter++;
    }
    var union = keysA.length + keysB.length - inter;
    var jaccard = union > 0 ? inter / union : 0;
    if (jaccard > 0.5) {
      var nA = nodeMap[partsOC[0]];
      var nB = nodeMap[partsOC[1]];
      overCoupled.push({
        a: partsOC[0],
        b: partsOC[1],
        nameA: nA ? nA.name : partsOC[0],
        nameB: nB ? nB.name : partsOC[1],
        jaccard: Math.round(jaccard * 10000) / 10000,
        sharedChanges: inter
      });
    }
  }
  overCoupled.sort(function (x, y) { return y.jaccard - x.jaccard; });

  // --- Under-coupled: share a business service but never co-occur ---
  var serviceMembers = {}; // serviceUid -> [ciUid]
  for (i = 0; i < graph.edges.length; i++) {
    var edgeUC = graph.edges[i];
    var svcUid = null;
    var ciInEdge = [];
    for (j = 0; j < edgeUC.elements.length; j++) {
      var eUid = edgeUC.elements[j];
      if (eUid.indexOf('service:') === 0) svcUid = eUid;
      if (ciSet[eUid]) ciInEdge.push(eUid);
    }
    if (svcUid) {
      if (!serviceMembers[svcUid]) serviceMembers[svcUid] = {};
      for (j = 0; j < ciInEdge.length; j++) {
        serviceMembers[svcUid][ciInEdge[j]] = true;
      }
    }
  }

  var underCoupled = [];
  var svcKeys = Object.keys(serviceMembers);
  for (i = 0; i < svcKeys.length; i++) {
    var members = Object.keys(serviceMembers[svcKeys[i]]);
    for (var m1 = 0; m1 < members.length; m1++) {
      for (var m2 = m1 + 1; m2 < members.length; m2++) {
        var ucKey = this._pairKey(members[m1], members[m2]);
        if (!pairCooccur[ucKey]) {
          var nUC1 = nodeMap[members[m1]];
          var nUC2 = nodeMap[members[m2]];
          underCoupled.push({
            a: members[m1],
            b: members[m2],
            nameA: nUC1 ? nUC1.name : members[m1],
            nameB: nUC2 ? nUC2.name : members[m2],
            sharedService: svcKeys[i],
            reason: 'share business service but never appear in the same change'
          });
        }
      }
    }
  }

  return {
    unexpectedPairs: unexpectedPairs,
    orphans: orphans,
    overCoupled: overCoupled,
    underCoupled: underCoupled
  };
};

/**
 * Generate a per-CI risk heatmap with multi-factor scoring.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {Object} rawData - Output of ITILDataSimulator.generate()
 * @returns {Array<{ci, name, riskScore, factors}>}
 */
AnalyticsEngine.prototype.riskHeatmap = function (graph, rawData) {
  if (!graph || !graph.nodes) return [];

  var nodeMap = this._nodeMap(graph);
  var ciUids = this._ciNodes(graph);
  var ciSet = {};
  var i, j;
  for (i = 0; i < ciUids.length; i++) {
    ciSet[ciUids[i]] = true;
  }

  var changeList = this._changeList(rawData || { taskCiRecords: [] });

  // Per-CI metrics
  var ciStats = {}; // uid -> { changeCount, emergencyCount, coupledCIs (Set) }
  for (i = 0; i < ciUids.length; i++) {
    ciStats[ciUids[i]] = { changeCount: 0, emergencyCount: 0, coupledCIs: {} };
  }

  // Accumulate from change list
  for (i = 0; i < changeList.length; i++) {
    var chg = changeList[i];
    var isEmergency = (chg.changeType === 'Emergency');
    for (j = 0; j < chg.ciUids.length; j++) {
      var ciUid = chg.ciUids[j];
      if (!ciStats[ciUid]) continue;
      ciStats[ciUid].changeCount++;
      if (isEmergency) ciStats[ciUid].emergencyCount++;
    }
    // Track coupling
    for (var a = 0; a < chg.ciUids.length; a++) {
      for (var b = a + 1; b < chg.ciUids.length; b++) {
        if (ciStats[chg.ciUids[a]]) ciStats[chg.ciUids[a]].coupledCIs[chg.ciUids[b]] = true;
        if (ciStats[chg.ciUids[b]]) ciStats[chg.ciUids[b]].coupledCIs[chg.ciUids[a]] = true;
      }
    }
  }

  // Count incidents per CI if available in rawData
  var incidentCounts = {};
  if (rawData && rawData.incidents) {
    var incKeys = Object.keys(rawData.incidents);
    for (i = 0; i < incKeys.length; i++) {
      var inc = rawData.incidents[incKeys[i]];
      if (inc.affectedCI && inc.affectedCI.id) {
        var incCiUid = 'ci:' + inc.affectedCI.id;
        incidentCounts[incCiUid] = (incidentCounts[incCiUid] || 0) + 1;
      }
    }
  }

  // Compute raw factors
  var rawFactors = [];
  for (i = 0; i < ciUids.length; i++) {
    var uid = ciUids[i];
    var stats = ciStats[uid];
    var changeFreq = stats.changeCount;
    var emergencyRatio = stats.changeCount > 0 ? stats.emergencyCount / stats.changeCount : 0;
    var incidentRate = incidentCounts[uid] || 0;
    var couplingDensity = Object.keys(stats.coupledCIs).length;

    rawFactors.push({
      uid: uid,
      changeFrequency: changeFreq,
      emergencyRatio: emergencyRatio,
      incidentRate: incidentRate,
      couplingDensity: couplingDensity
    });
  }

  // Find maxima for normalization
  var maxCF = 0, maxER = 0, maxIR = 0, maxCD = 0;
  for (i = 0; i < rawFactors.length; i++) {
    if (rawFactors[i].changeFrequency > maxCF) maxCF = rawFactors[i].changeFrequency;
    if (rawFactors[i].emergencyRatio > maxER) maxER = rawFactors[i].emergencyRatio;
    if (rawFactors[i].incidentRate > maxIR) maxIR = rawFactors[i].incidentRate;
    if (rawFactors[i].couplingDensity > maxCD) maxCD = rawFactors[i].couplingDensity;
  }

  // Build final results
  var results = [];
  for (i = 0; i < rawFactors.length; i++) {
    var rf = rawFactors[i];
    var node = nodeMap[rf.uid];
    var nCF = maxCF > 0 ? rf.changeFrequency / maxCF : 0;
    var nER = maxER > 0 ? rf.emergencyRatio / maxER : 0;
    var nIR = maxIR > 0 ? rf.incidentRate / maxIR : 0;
    var nCD = maxCD > 0 ? rf.couplingDensity / maxCD : 0;

    var riskScore = Math.round((0.3 * nCF + 0.25 * nER + 0.25 * nIR + 0.2 * nCD) * 100);

    results.push({
      ci: rf.uid,
      name: node ? node.name : rf.uid,
      riskScore: riskScore,
      factors: {
        changeFrequency: rf.changeFrequency,
        emergencyRatio: Math.round(rf.emergencyRatio * 10000) / 10000,
        incidentRate: rf.incidentRate,
        couplingDensity: rf.couplingDensity
      }
    });
  }

  results.sort(function (x, y) { return y.riskScore - x.riskScore; });
  return results;
};

// ===================================================================
//  5. Community Detection (Louvain-inspired)
// ===================================================================

/**
 * Detect communities of CIs using a simplified Louvain algorithm on the
 * projected adjacency matrix (weighted by co-occurrence count).
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @returns {Object} { communities, modularity, summary }
 */
AnalyticsEngine.prototype.detectCommunities = function (graph) {
  if (!graph || !graph.nodes) {
    return { communities: {}, modularity: 0, summary: [] };
  }

  var proj = this._projectedAdjacency(graph);
  var nodes = proj.nodes;   // CI uids only
  var matrix = proj.matrix;
  var n = nodes.length;

  if (n === 0) {
    return { communities: {}, modularity: 0, summary: [] };
  }

  // Total edge weight (sum of all weights / 2 since symmetric)
  var m2 = 0; // 2m
  var i, j;
  for (i = 0; i < n; i++) {
    var row = matrix[nodes[i]];
    var rKeys = Object.keys(row);
    for (j = 0; j < rKeys.length; j++) {
      m2 += row[rKeys[j]];
    }
  }
  // m2 already counts each edge twice (symmetric), so m = m2/2
  var m = m2 / 2;

  if (m === 0) {
    // No edges; each node is its own community
    var trivial = {};
    for (i = 0; i < n; i++) {
      trivial[i] = [nodes[i]];
    }
    return { communities: trivial, modularity: 0, summary: this._communitySummary(trivial, graph) };
  }

  // Weighted degree (strength) of each node
  var strength = {};
  for (i = 0; i < n; i++) {
    var s = 0;
    var sRow = matrix[nodes[i]];
    var sKeys = Object.keys(sRow);
    for (j = 0; j < sKeys.length; j++) {
      s += sRow[sKeys[j]];
    }
    strength[nodes[i]] = s;
  }

  // Initialise each node in its own community
  var community = {}; // nodeUid -> communityId
  for (i = 0; i < n; i++) {
    community[nodes[i]] = i;
  }

  // Iterative optimisation
  var improved = true;
  var maxIterations = 50;
  var iteration = 0;

  while (improved && iteration < maxIterations) {
    improved = false;
    iteration++;

    for (i = 0; i < n; i++) {
      var nodeUid = nodes[i];
      var currentCom = community[nodeUid];
      var ki = strength[nodeUid];

      // Compute sum of weights to each neighbouring community
      var neighborComs = {}; // comId -> sumWeight
      var nRow = matrix[nodeUid];
      var nKeys = Object.keys(nRow);
      for (j = 0; j < nKeys.length; j++) {
        var neighborUid = nKeys[j];
        var nc = community[neighborUid];
        if (nc === undefined) continue;
        neighborComs[nc] = (neighborComs[nc] || 0) + nRow[neighborUid];
      }

      // Sum of weights inside current community (connections from this node to current com)
      var sigmaIn = neighborComs[currentCom] || 0;

      // Sum of total weights for current community
      var sigmaTot = 0;
      for (j = 0; j < n; j++) {
        if (community[nodes[j]] === currentCom && nodes[j] !== nodeUid) {
          sigmaTot += strength[nodes[j]];
        }
      }

      // Modularity gain of removing node from its community
      var removeGain = sigmaIn / m - (sigmaTot * ki) / (2 * m * m);

      // Find best community to move to
      var bestCom = currentCom;
      var bestGain = 0;
      var comIds = Object.keys(neighborComs);

      for (j = 0; j < comIds.length; j++) {
        var targetCom = parseInt(comIds[j], 10);
        if (targetCom === currentCom) continue;

        var kIn = neighborComs[comIds[j]]; // weight to target community
        var sigmaTarget = 0;
        for (var k = 0; k < n; k++) {
          if (community[nodes[k]] === targetCom) {
            sigmaTarget += strength[nodes[k]];
          }
        }

        var gain = kIn / m - (sigmaTarget * ki) / (2 * m * m);
        var deltaQ = gain - removeGain;

        if (deltaQ > bestGain) {
          bestGain = deltaQ;
          bestCom = targetCom;
        }
      }

      if (bestCom !== currentCom && bestGain > 0) {
        community[nodeUid] = bestCom;
        improved = true;
      }
    }
  }

  // Build communities map
  var communities = {};
  for (i = 0; i < n; i++) {
    var cid = community[nodes[i]];
    if (!communities[cid]) communities[cid] = [];
    communities[cid].push(nodes[i]);
  }

  // Compute final modularity Q
  var Q = 0;
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      if (community[nodes[i]] !== community[nodes[j]]) continue;
      var Aij = (matrix[nodes[i]] && matrix[nodes[i]][nodes[j]]) ? matrix[nodes[i]][nodes[j]] : 0;
      Q += Aij - (strength[nodes[i]] * strength[nodes[j]]) / (2 * m);
    }
  }
  Q = Q / (2 * m);

  return {
    communities: communities,
    modularity: Math.round(Q * 10000) / 10000,
    summary: this._communitySummary(communities, graph)
  };
};

/**
 * Build summary metadata for each detected community.
 * @private
 */
AnalyticsEngine.prototype._communitySummary = function (communities, graph) {
  var nodeMap = this._nodeMap(graph);
  var result = [];
  var comIds = Object.keys(communities);

  for (var i = 0; i < comIds.length; i++) {
    var members = communities[comIds[i]];
    var typeCounts = {};
    var serviceCounts = {};

    for (var j = 0; j < members.length; j++) {
      var node = nodeMap[members[j]];
      if (!node) continue;
      var cls = node.className || node.type || 'unknown';
      typeCounts[cls] = (typeCounts[cls] || 0) + 1;

      // Find services this CI is connected to
      var edgeSet = graph.incidence[members[j]];
      if (edgeSet) {
        var edgeArr = Array.from(edgeSet);
        for (var e = 0; e < graph.edges.length; e++) {
          if (!edgeSet.has(graph.edges[e].uid)) continue;
          var svcName = graph.edges[e].businessService;
          if (svcName) serviceCounts[svcName] = (serviceCounts[svcName] || 0) + 1;
        }
      }
    }

    // Dominant type
    var dominantType = 'unknown';
    var maxTypeCount = 0;
    var typeKeys = Object.keys(typeCounts);
    for (var t = 0; t < typeKeys.length; t++) {
      if (typeCounts[typeKeys[t]] > maxTypeCount) {
        maxTypeCount = typeCounts[typeKeys[t]];
        dominantType = typeKeys[t];
      }
    }

    // Dominant service
    var dominantService = 'unknown';
    var maxSvcCount = 0;
    var svcKeys = Object.keys(serviceCounts);
    for (var s = 0; s < svcKeys.length; s++) {
      if (serviceCounts[svcKeys[s]] > maxSvcCount) {
        maxSvcCount = serviceCounts[svcKeys[s]];
        dominantService = svcKeys[s];
      }
    }

    result.push({
      id: comIds[i],
      size: members.length,
      dominantType: dominantType,
      dominantService: dominantService
    });
  }

  result.sort(function (a, b) { return b.size - a.size; });
  return result;
};

// ===================================================================
//  6. Change Impact Prediction
// ===================================================================

/**
 * Predict which CIs are likely to be impacted when a given CI changes.
 *
 * Score is a weighted combination of co-occurrence frequency, temporal
 * cascade history, shared business service membership, and network
 * proximity.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {Object} rawData - Output of ITILDataSimulator.generate()
 * @param {string} targetCiUid - UID of the CI about to change
 * @returns {Array<{ci, name, probability, reason}>}
 */
AnalyticsEngine.prototype.predictImpact = function (graph, rawData, targetCiUid) {
  if (!graph || !graph.nodes || !targetCiUid) return [];

  var nodeMap = this._nodeMap(graph);
  if (!nodeMap[targetCiUid]) return [];

  var ciUids = this._ciNodes(graph);
  var ciSet = {};
  var i, j;
  for (i = 0; i < ciUids.length; i++) {
    ciSet[ciUids[i]] = true;
  }

  // 1. Co-occurrence frequency
  var cooccurCount = {}; // otherCi -> count
  var edgeSet = graph.incidence[targetCiUid];
  if (edgeSet) {
    var edgeArr = Array.from(edgeSet);
    for (i = 0; i < graph.edges.length; i++) {
      var edge = graph.edges[i];
      if (!edgeSet.has(edge.uid)) continue;
      for (j = 0; j < edge.elements.length; j++) {
        var el = edge.elements[j];
        if (el !== targetCiUid && ciSet[el]) {
          cooccurCount[el] = (cooccurCount[el] || 0) + 1;
        }
      }
    }
  }

  // 2. Temporal cascades (target -> other)
  var cascades = {};
  if (rawData && rawData.taskCiRecords) {
    var changeList = this._changeList(rawData);
    var targetChanges = [];
    var otherChanges = {}; // ciUid -> [{time}]

    for (i = 0; i < changeList.length; i++) {
      var chg = changeList[i];
      var hasTarget = false;
      for (j = 0; j < chg.ciUids.length; j++) {
        if (chg.ciUids[j] === targetCiUid) hasTarget = true;
      }
      if (hasTarget) targetChanges.push(chg.createdAt);
      for (j = 0; j < chg.ciUids.length; j++) {
        var cu = chg.ciUids[j];
        if (cu !== targetCiUid && ciSet[cu]) {
          if (!otherChanges[cu]) otherChanges[cu] = [];
          otherChanges[cu].push(chg.createdAt);
        }
      }
    }

    var windowMs = 7 * 24 * 60 * 60 * 1000;
    var otherKeys = Object.keys(otherChanges);
    for (i = 0; i < otherKeys.length; i++) {
      var oUid = otherKeys[i];
      var oTimes = otherChanges[oUid];
      var cascadeCount = 0;
      for (var tc = 0; tc < targetChanges.length; tc++) {
        for (var oc = 0; oc < oTimes.length; oc++) {
          var lag = oTimes[oc] - targetChanges[tc];
          if (lag > 0 && lag <= windowMs) {
            cascadeCount++;
          }
        }
      }
      if (cascadeCount > 0) cascades[oUid] = cascadeCount;
    }
  }

  // 3. Shared business service membership
  var targetServices = {};
  var ciServices = {}; // otherCi -> Set(serviceUid)
  for (i = 0; i < graph.edges.length; i++) {
    var edgeSvc = graph.edges[i];
    var hasT = false;
    var svcUid = null;
    var edgeCIs = [];
    for (j = 0; j < edgeSvc.elements.length; j++) {
      if (edgeSvc.elements[j] === targetCiUid) hasT = true;
      if (edgeSvc.elements[j].indexOf('service:') === 0) svcUid = edgeSvc.elements[j];
      if (ciSet[edgeSvc.elements[j]] && edgeSvc.elements[j] !== targetCiUid) {
        edgeCIs.push(edgeSvc.elements[j]);
      }
    }
    if (hasT && svcUid) targetServices[svcUid] = true;
    if (svcUid) {
      for (j = 0; j < edgeCIs.length; j++) {
        if (!ciServices[edgeCIs[j]]) ciServices[edgeCIs[j]] = {};
        ciServices[edgeCIs[j]][svcUid] = true;
      }
    }
  }
  var sharedService = {};
  var csKeys = Object.keys(ciServices);
  for (i = 0; i < csKeys.length; i++) {
    var svcSet = ciServices[csKeys[i]];
    var shared = 0;
    var sKeys = Object.keys(svcSet);
    for (j = 0; j < sKeys.length; j++) {
      if (targetServices[sKeys[j]]) shared++;
    }
    if (shared > 0) sharedService[csKeys[i]] = shared;
  }

  // 4. Network proximity (shared neighbor ratio)
  var targetNeighbors = {};
  var neighborCount = 0;
  if (edgeSet) {
    for (i = 0; i < graph.edges.length; i++) {
      if (!edgeSet.has(graph.edges[i].uid)) continue;
      for (j = 0; j < graph.edges[i].elements.length; j++) {
        var ne = graph.edges[i].elements[j];
        if (ne !== targetCiUid) {
          targetNeighbors[ne] = true;
          neighborCount++;
        }
      }
    }
  }

  var proximity = {};
  for (i = 0; i < ciUids.length; i++) {
    var otherUid = ciUids[i];
    if (otherUid === targetCiUid) continue;
    var otherEdgeSet = graph.incidence[otherUid];
    if (!otherEdgeSet) continue;
    var otherNeighbors = {};
    for (j = 0; j < graph.edges.length; j++) {
      if (!otherEdgeSet.has(graph.edges[j].uid)) continue;
      for (var k = 0; k < graph.edges[j].elements.length; k++) {
        var ne2 = graph.edges[j].elements[k];
        if (ne2 !== otherUid) otherNeighbors[ne2] = true;
      }
    }
    // Count shared neighbors
    var sharedN = 0;
    var totalN = 0;
    var onKeys = Object.keys(otherNeighbors);
    for (j = 0; j < onKeys.length; j++) {
      totalN++;
      if (targetNeighbors[onKeys[j]]) sharedN++;
    }
    var tnKeys = Object.keys(targetNeighbors);
    for (j = 0; j < tnKeys.length; j++) {
      if (!otherNeighbors[tnKeys[j]]) totalN++;
    }
    if (totalN > 0) {
      proximity[otherUid] = sharedN / totalN;
    }
  }

  // Normalize each signal
  var maxCooccur = 0, maxCascade = 0, maxSvcShare = 0;
  for (i = 0; i < ciUids.length; i++) {
    var u = ciUids[i];
    if ((cooccurCount[u] || 0) > maxCooccur) maxCooccur = cooccurCount[u];
    if ((cascades[u] || 0) > maxCascade) maxCascade = cascades[u];
    if ((sharedService[u] || 0) > maxSvcShare) maxSvcShare = sharedService[u];
  }

  // Combine scores
  var results = [];
  for (i = 0; i < ciUids.length; i++) {
    var cUid = ciUids[i];
    if (cUid === targetCiUid) continue;

    var sCooccur = maxCooccur > 0 ? (cooccurCount[cUid] || 0) / maxCooccur : 0;
    var sCascade = maxCascade > 0 ? (cascades[cUid] || 0) / maxCascade : 0;
    var sSvc = maxSvcShare > 0 ? (sharedService[cUid] || 0) / maxSvcShare : 0;
    var sProx = proximity[cUid] || 0;

    var probability = 0.35 * sCooccur + 0.25 * sCascade + 0.2 * sSvc + 0.2 * sProx;
    if (probability === 0) continue;

    // Determine primary reason
    var maxSignal = Math.max(sCooccur, sCascade, sSvc, sProx);
    var reason = 'network proximity';
    if (maxSignal === sCooccur && sCooccur > 0) {
      reason = 'frequently co-occurs in change requests';
    } else if (maxSignal === sCascade && sCascade > 0) {
      reason = 'temporal cascade pattern detected';
    } else if (maxSignal === sSvc && sSvc > 0) {
      reason = 'shared business service membership';
    }

    var cNode = nodeMap[cUid];
    results.push({
      ci: cUid,
      name: cNode ? cNode.name : cUid,
      probability: Math.round(probability * 10000) / 10000,
      reason: reason
    });
  }

  results.sort(function (x, y) { return y.probability - x.probability; });
  return results;
};

/**
 * Predict CI pairs most likely to appear together in future changes
 * using the Adamic-Adar index on the projected CI graph.
 *
 * Considers only pairs that do NOT currently co-occur.
 *
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @param {number} [topN=20] - Number of top predictions to return
 * @returns {Array<{a, b, nameA, nameB, score}>}
 */
AnalyticsEngine.prototype.linkPrediction = function (graph, topN) {
  topN = topN || 20;

  if (!graph || !graph.nodes) return [];

  var proj = this._projectedAdjacency(graph);
  var nodes = proj.nodes;
  var matrix = proj.matrix;
  var n = nodes.length;
  var nodeMap = this._nodeMap(graph);

  if (n < 2) return [];

  // Build neighbor sets and degree map
  var neighbors = {}; // uid -> { neighborUid: true }
  var degree = {};
  var i, j;
  for (i = 0; i < n; i++) {
    var uid = nodes[i];
    neighbors[uid] = {};
    var row = matrix[uid];
    var rKeys = Object.keys(row);
    for (j = 0; j < rKeys.length; j++) {
      if (row[rKeys[j]] > 0) {
        neighbors[uid][rKeys[j]] = true;
      }
    }
    degree[uid] = Object.keys(neighbors[uid]).length;
  }

  // Existing pairs
  var existingPairs = {};
  for (i = 0; i < n; i++) {
    var nKeys = Object.keys(neighbors[nodes[i]]);
    for (j = 0; j < nKeys.length; j++) {
      existingPairs[this._pairKey(nodes[i], nKeys[j])] = true;
    }
  }

  // Compute Adamic-Adar for non-existing pairs
  var results = [];
  for (i = 0; i < n; i++) {
    for (j = i + 1; j < n; j++) {
      var u = nodes[i];
      var v = nodes[j];
      var pk = this._pairKey(u, v);
      if (existingPairs[pk]) continue; // skip already-connected pairs

      // Common neighbors
      var score = 0;
      var uNeighbors = Object.keys(neighbors[u]);
      for (var k = 0; k < uNeighbors.length; k++) {
        var w = uNeighbors[k];
        if (neighbors[v][w]) {
          var degW = degree[w];
          if (degW > 1) {
            score += 1 / Math.log(degW);
          }
        }
      }

      if (score > 0) {
        var nU = nodeMap[u];
        var nV = nodeMap[v];
        results.push({
          a: u,
          b: v,
          nameA: nU ? nU.name : u,
          nameB: nV ? nV.name : v,
          score: Math.round(score * 10000) / 10000
        });
      }
    }
  }

  results.sort(function (x, y) { return y.score - x.score; });
  return results.slice(0, topN);
};

// ===================================================================
//  7. Incident Correlation
// ===================================================================

/**
 * Analyse incident patterns relative to the change/CI graph.
 *
 * @param {Array} incidents - Array of incident objects:
 *   { number, priority (1-4), affectedCI: {id, name},
 *     businessService: {id, name}, createdAt, resolvedAt,
 *     relatedIncidents: [], assignmentGroup: {id, name} }
 * @param {Object} graph - Hypergraph from HypergraphCore.build()
 * @returns {Object} { faultPropagation, hotspots, serviceFingerprints }
 */
AnalyticsEngine.prototype.incidentCorrelation = function (incidents, graph) {
  if (!incidents || incidents.length === 0) {
    return { faultPropagation: [], hotspots: [], serviceFingerprints: {} };
  }

  var nodeMap = graph ? this._nodeMap(graph) : {};
  var i, j;

  // --- Fault Propagation ---
  // For each CI, build a timeline of incidents sorted by createdAt
  var ciIncidents = {}; // ciUid -> [{ time, number }]
  for (i = 0; i < incidents.length; i++) {
    var inc = incidents[i];
    if (!inc.affectedCI || !inc.affectedCI.id) continue;
    var ciUid = 'ci:' + inc.affectedCI.id;
    if (!ciIncidents[ciUid]) ciIncidents[ciUid] = [];
    ciIncidents[ciUid].push({
      time: this._parseDate(inc.createdAt),
      number: inc.number
    });
  }
  var ciKeys = Object.keys(ciIncidents);
  for (i = 0; i < ciKeys.length; i++) {
    ciIncidents[ciKeys[i]].sort(function (a, b) { return a.time - b.time; });
  }

  // Detect propagation: incident on CI-A followed by incident on CI-B within 24h
  var propMap = {}; // "A|B" -> { count, totalLag }
  var propWindowMs = 24 * 60 * 60 * 1000;
  for (i = 0; i < ciKeys.length; i++) {
    for (j = 0; j < ciKeys.length; j++) {
      if (i === j) continue;
      var srcInc = ciIncidents[ciKeys[i]];
      var tgtInc = ciIncidents[ciKeys[j]];
      for (var si = 0; si < srcInc.length; si++) {
        if (srcInc[si].time === 0) continue;
        for (var ti = 0; ti < tgtInc.length; ti++) {
          if (tgtInc[ti].time === 0) continue;
          var lag = tgtInc[ti].time - srcInc[si].time;
          if (lag > 0 && lag <= propWindowMs) {
            var propKey = ciKeys[i] + '|' + ciKeys[j];
            if (!propMap[propKey]) propMap[propKey] = { count: 0, totalLag: 0 };
            propMap[propKey].count++;
            propMap[propKey].totalLag += lag;
          }
        }
      }
    }
  }

  var faultPropagation = [];
  var propKeys = Object.keys(propMap);
  for (i = 0; i < propKeys.length; i++) {
    var parts = propKeys[i].split('|');
    var entry = propMap[propKeys[i]];
    faultPropagation.push({
      source: parts[0],
      target: parts[1],
      count: entry.count,
      avgLagHours: Math.round((entry.totalLag / entry.count) / (60 * 60 * 1000) * 100) / 100
    });
  }
  faultPropagation.sort(function (a, b) { return b.count - a.count; });

  // --- Hotspots ---
  var ciHotspot = {}; // ciUid -> { count, prioritySum, times: [] }
  for (i = 0; i < incidents.length; i++) {
    var hInc = incidents[i];
    if (!hInc.affectedCI || !hInc.affectedCI.id) continue;
    var hUid = 'ci:' + hInc.affectedCI.id;
    if (!ciHotspot[hUid]) {
      ciHotspot[hUid] = { count: 0, prioritySum: 0, times: [] };
    }
    ciHotspot[hUid].count++;
    ciHotspot[hUid].prioritySum += (hInc.priority || 4);
    ciHotspot[hUid].times.push(this._parseDate(hInc.createdAt));
  }

  var hotspots = [];
  var hKeys = Object.keys(ciHotspot);
  for (i = 0; i < hKeys.length; i++) {
    var hs = ciHotspot[hKeys[i]];
    var avgPriority = hs.count > 0 ? hs.prioritySum / hs.count : 4;

    // MTBF (Mean Time Between Failures)
    var times = hs.times.filter(function (t) { return t > 0; });
    times.sort(function (a, b) { return a - b; });
    var mtbfHours = 0;
    if (times.length > 1) {
      var totalGap = 0;
      for (j = 1; j < times.length; j++) {
        totalGap += times[j] - times[j - 1];
      }
      mtbfHours = (totalGap / (times.length - 1)) / (60 * 60 * 1000);
    }

    var hNode = nodeMap[hKeys[i]];
    hotspots.push({
      ci: hKeys[i],
      name: hNode ? hNode.name : hKeys[i],
      incidentCount: hs.count,
      avgPriority: Math.round(avgPriority * 100) / 100,
      mtbf: Math.round(mtbfHours * 100) / 100
    });
  }
  hotspots.sort(function (a, b) { return b.incidentCount - a.incidentCount; });

  // --- Service Fingerprints ---
  var serviceFingerprints = {};
  for (i = 0; i < incidents.length; i++) {
    var sfInc = incidents[i];
    if (!sfInc.businessService || !sfInc.businessService.id) continue;
    var svcUid = 'service:' + sfInc.businessService.id;
    if (!serviceFingerprints[svcUid]) {
      serviceFingerprints[svcUid] = {
        affectedCIs: {},
        resolutionTimes: [],
        incidentCount: 0
      };
    }
    var fp = serviceFingerprints[svcUid];
    fp.incidentCount++;
    if (sfInc.affectedCI && sfInc.affectedCI.id) {
      fp.affectedCIs['ci:' + sfInc.affectedCI.id] = true;
    }
    // Resolution time
    var created = this._parseDate(sfInc.createdAt);
    var resolved = this._parseDate(sfInc.resolvedAt);
    if (created > 0 && resolved > 0 && resolved > created) {
      fp.resolutionTimes.push(resolved - created);
    }
  }

  // Finalize fingerprints
  var finalFingerprints = {};
  var fpKeys = Object.keys(serviceFingerprints);
  for (i = 0; i < fpKeys.length; i++) {
    var sfp = serviceFingerprints[fpKeys[i]];
    var affectedArr = Object.keys(sfp.affectedCIs);
    var totalResMs = 0;
    for (j = 0; j < sfp.resolutionTimes.length; j++) {
      totalResMs += sfp.resolutionTimes[j];
    }
    var avgResHours = sfp.resolutionTimes.length > 0
      ? (totalResMs / sfp.resolutionTimes.length) / (60 * 60 * 1000)
      : 0;

    // Pattern: concentrated if <= 3 CIs affected, distributed otherwise
    var pattern = affectedArr.length <= 3 ? 'concentrated' : 'distributed';

    finalFingerprints[fpKeys[i]] = {
      affectedCIs: affectedArr,
      pattern: pattern,
      avgResolutionHours: Math.round(avgResHours * 100) / 100
    };
  }

  return {
    faultPropagation: faultPropagation,
    hotspots: hotspots,
    serviceFingerprints: finalFingerprints
  };
};

/* ── UpSetRenderer ── */
/**
 * UpSet Plot Renderer -- D3-based Set Intersection Visualization
 *
 * Renders a HypergraphCore graph as an UpSet plot showing which combinations
 * of CIs (or other entity types) appear together in change requests, how
 * frequently each combination occurs, and superset/subset relationships.
 *
 * The UpSet plot has three visual components:
 *   1. Intersection Size bar chart (top)   -- vertical bars per combination
 *   2. Matrix dot grid (middle)            -- entity membership indicator
 *   3. Set Size bar chart (left)           -- horizontal bars per entity
 *
 * Usage:
 *   var upset = new UpSetRenderer('#graph-container', {
 *     onIntersectionClick: function (intersection) { ... }
 *   });
 *   upset.render(hypergraphData);
 *   upset.destroy();
 *
 * @constructor
 * @param {string} containerSelector - CSS selector for the container div
 * @param {Object} [options]
 * @param {Function} [options.onIntersectionClick] - callback(intersection) on bar click
 */

/* global d3 */

function UpSetRenderer(containerSelector, options) {
  options = options || {};
  this.containerSelector = containerSelector;
  this._onIntersectionClick = options.onIntersectionClick || null;

  this.svg = null;
  this._tooltip = null;
  this._currentGraph = null;
  this._lastRenderOptions = null;

  // Color scheme (matches existing app dark theme)
  this._colors = {
    ci: '#4fc3f7',
    group: '#ffb74d',
    service: '#81c784',
    change: '#ce93d8',
    bar: '#4fc3f7',
    barMuted: 'rgba(79, 195, 247, 0.55)',
    dotEmpty: '#21262d',
    connector: '#6e7681',
    text: '#e6edf3',
    textSecondary: '#8b949e',
    textMuted: '#6e7681',
    gridLine: '#30363d',
    rowEven: 'rgba(33, 38, 45, 0.35)',
    rowOdd: 'transparent'
  };

  // Layout constants
  this._layout = {
    margin: { top: 20, right: 20, bottom: 10, left: 200 },
    barHeight: 200,
    dotRowHeight: 16,
    dotRadius: 5,
    barWidth: 18,
    gap: 4,
    setSizeBarWidth: 120
  };
}

// ---------------------------------------------------------------------------
// Public API
// ---------------------------------------------------------------------------

/**
 * Render the UpSet plot from a HypergraphCore graph.
 *
 * @param {Object} graph - { nodes, edges, incidence }
 * @param {Object} [options]
 * @param {number} [options.maxIntersections=30] - max combinations to show
 * @param {string|null} [options.filterType='ci'] - only include nodes of this type (null = all)
 * @param {number} [options.minSetSize=1] - minimum intersection size to include
 */
UpSetRenderer.prototype.render = function (graph, options) {
  options = options || {};
  var maxIntersections = options.maxIntersections != null ? options.maxIntersections : 30;
  var filterType = options.filterType !== undefined ? options.filterType : 'ci';
  var minSetSize = options.minSetSize != null ? options.minSetSize : 1;
  var topN = options.topEntities != null ? options.topEntities : 0;

  this._currentGraph = graph;
  this._lastRenderOptions = options;

  // -- 1. Build node lookup ------------------------------------------------
  var nodeById = {};
  var i, j;
  for (i = 0; i < graph.nodes.length; i++) {
    nodeById[graph.nodes[i].uid] = graph.nodes[i];
  }

  // -- 1b. If topEntities is set, find the N most-connected entities -------
  //    This prevents the "all intersections = 1" problem when the entity
  //    space is too large relative to the number of edges.
  var topEntitySet = null;
  if (topN > 0) {
    var degreeList = [];
    for (i = 0; i < graph.nodes.length; i++) {
      var nd = graph.nodes[i];
      if (filterType && nd.type !== filterType) continue;
      var inc = graph.incidence[nd.uid];
      degreeList.push({ uid: nd.uid, deg: inc ? inc.size : 0 });
    }
    degreeList.sort(function (a, b) { return b.deg - a.deg; });
    topEntitySet = {};
    for (i = 0; i < Math.min(topN, degreeList.length); i++) {
      topEntitySet[degreeList[i].uid] = true;
    }
  }

  // -- 2. Build intersection fingerprints ----------------------------------
  var fingerprints = {}; // key -> { members: [uid,...], edges: [edgeObj,...] }
  for (i = 0; i < graph.edges.length; i++) {
    var edge = graph.edges[i];
    var filteredMembers = [];
    for (j = 0; j < edge.elements.length; j++) {
      var uid = edge.elements[j];
      var node = nodeById[uid];
      if (!node) continue;
      if (filterType && node.type !== filterType) continue;
      if (topEntitySet && !topEntitySet[uid]) continue;
      filteredMembers.push(uid);
    }
    if (filteredMembers.length < minSetSize) continue;
    filteredMembers.sort();
    var key = filteredMembers.join('|');
    if (!fingerprints[key]) {
      fingerprints[key] = { members: filteredMembers, edges: [] };
    }
    fingerprints[key].edges.push(edge);
  }

  // -- 3. Count and sort by frequency --------------------------------------
  var fpKeys = Object.keys(fingerprints);
  var intersections = [];
  for (i = 0; i < fpKeys.length; i++) {
    var fp = fingerprints[fpKeys[i]];
    intersections.push({
      members: fp.members,
      count: fp.edges.length,
      edges: fp.edges
    });
  }
  intersections.sort(function (a, b) { return b.count - a.count; });
  intersections = intersections.slice(0, maxIntersections);

  // -- 4. Identify active entities -----------------------------------------
  var activeSet = {};
  for (i = 0; i < intersections.length; i++) {
    for (j = 0; j < intersections[i].members.length; j++) {
      var mUid = intersections[i].members[j];
      if (!activeSet[mUid]) activeSet[mUid] = 0;
      activeSet[mUid] += intersections[i].count;
    }
  }

  // Build entity frequency map (total changes containing this entity)
  var entityFreq = {};
  var entityUids = Object.keys(activeSet);
  for (i = 0; i < entityUids.length; i++) {
    var eUid = entityUids[i];
    var incSet = graph.incidence[eUid];
    entityFreq[eUid] = incSet ? incSet.size : 0;
  }

  // -- 5. Sort entities by total frequency (most frequent at top) ----------
  var entities = [];
  for (i = 0; i < entityUids.length; i++) {
    entities.push({
      uid: entityUids[i],
      node: nodeById[entityUids[i]],
      freq: entityFreq[entityUids[i]]
    });
  }
  entities.sort(function (a, b) { return b.freq - a.freq; });

  // Entity index lookup (uid -> row index)
  var entityIndex = {};
  for (i = 0; i < entities.length; i++) {
    entityIndex[entities[i].uid] = i;
  }

  // -- 6. Render -----------------------------------------------------------
  this._renderSVG(intersections, entities, entityIndex, nodeById);
};

/**
 * Remove the SVG, tooltip, and event listeners.
 */
UpSetRenderer.prototype.destroy = function () {
  if (this._tooltip) {
    this._tooltip.remove();
    this._tooltip = null;
  }
  var container = d3.select(this.containerSelector);
  container.select('svg.upset-svg').remove();
  this.svg = null;
  this._currentGraph = null;
};

/**
 * Re-render with new container dimensions (preserving last data and options).
 */
UpSetRenderer.prototype.resize = function () {
  if (this._currentGraph) {
    this.render(this._currentGraph, this._lastRenderOptions);
  }
};

// ---------------------------------------------------------------------------
// Internal rendering
// ---------------------------------------------------------------------------

/**
 * @private
 */
UpSetRenderer.prototype._renderSVG = function (intersections, entities, entityIndex, nodeById) {
  var self = this;
  var L = this._layout;
  var C = this._colors;

  // Clean up previous render
  var container = d3.select(this.containerSelector);
  container.select('svg.upset-svg').remove();
  if (this._tooltip) this._tooltip.remove();

  // Handle empty data
  if (intersections.length === 0 || entities.length === 0) {
    this._renderEmpty(container);
    return;
  }

  // Compute dimensions
  var numCols = intersections.length;
  var numRows = entities.length;

  var colWidth = L.barWidth + L.gap;
  var matrixWidth = numCols * colWidth;
  var matrixHeight = numRows * L.dotRowHeight;

  var totalWidth = L.margin.left + L.setSizeBarWidth + 10 + matrixWidth + L.margin.right;
  var totalHeight = L.margin.top + L.barHeight + 12 + matrixHeight + L.margin.bottom;

  var containerRect = container.node().getBoundingClientRect();
  var svgWidth = Math.max(totalWidth, containerRect.width || totalWidth);
  var svgHeight = Math.max(totalHeight, containerRect.height || totalHeight);

  // Create SVG
  this.svg = container.append('svg')
    .attr('class', 'upset-svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('viewBox', '0 0 ' + svgWidth + ' ' + svgHeight)
    .style('font-family', "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, sans-serif");

  // Origin for the matrix (top-left of dot grid)
  var matrixX = L.margin.left + L.setSizeBarWidth + 10;
  var matrixY = L.margin.top + L.barHeight + 12;

  // Tooltip
  this._tooltip = container.append('div')
    .attr('class', 'hg-tooltip upset-tooltip')
    .style('opacity', 0);

  // -- Scales --------------------------------------------------------------
  var maxCount = d3.max(intersections, function (d) { return d.count; }) || 1;
  var yBarScale = d3.scaleLinear()
    .domain([0, maxCount])
    .range([L.barHeight, 0]);

  var maxFreq = d3.max(entities, function (d) { return d.freq; }) || 1;
  var xSetScale = d3.scaleLinear()
    .domain([0, maxFreq])
    .range([0, L.setSizeBarWidth]);

  // -- 1. Intersection Size Bar Chart (top) --------------------------------
  var barGroup = this.svg.append('g')
    .attr('class', 'upset-bar-chart')
    .attr('transform', 'translate(' + matrixX + ',' + L.margin.top + ')');

  // Axis label
  barGroup.append('text')
    .attr('x', matrixWidth / 2)
    .attr('y', -6)
    .attr('text-anchor', 'middle')
    .attr('fill', C.textSecondary)
    .attr('font-size', '10px')
    .text('Intersection Size');

  // Y-axis grid lines
  var tickValues = yBarScale.ticks(5);
  for (var t = 0; t < tickValues.length; t++) {
    var yTick = yBarScale(tickValues[t]);
    barGroup.append('line')
      .attr('x1', 0)
      .attr('y1', yTick)
      .attr('x2', matrixWidth)
      .attr('y2', yTick)
      .attr('stroke', C.gridLine)
      .attr('stroke-width', 0.5);
    barGroup.append('text')
      .attr('x', -4)
      .attr('y', yTick + 3)
      .attr('text-anchor', 'end')
      .attr('fill', C.textMuted)
      .attr('font-size', '9px')
      .text(tickValues[t]);
  }

  // Bars
  for (var bi = 0; bi < intersections.length; bi++) {
    var inter = intersections[bi];
    var bx = bi * colWidth + L.gap / 2;
    var barH = L.barHeight - yBarScale(inter.count);

    (function (idx, intersection, xPos) {
      var bar = barGroup.append('rect')
        .attr('x', xPos)
        .attr('y', yBarScale(intersection.count))
        .attr('width', L.barWidth)
        .attr('height', barH)
        .attr('fill', C.bar)
        .attr('opacity', 0.8)
        .attr('rx', 2)
        .style('cursor', 'pointer');

      bar.on('mouseover', function (event) {
        d3.select(this).attr('opacity', 1);
        self._showBarTooltip(event, intersection, nodeById);
        self._highlightColumn(idx, numRows, matrixX, matrixY, colWidth, L.dotRowHeight);
      });
      bar.on('mouseout', function () {
        d3.select(this).attr('opacity', 0.8);
        self._hideTooltip();
        self._clearColumnHighlight();
      });
      bar.on('click', function () {
        if (self._onIntersectionClick) {
          self._onIntersectionClick({
            members: intersection.members,
            count: intersection.count,
            edges: intersection.edges
          });
        }
      });

      // Count label on top
      barGroup.append('text')
        .attr('x', xPos + L.barWidth / 2)
        .attr('y', yBarScale(intersection.count) - 4)
        .attr('text-anchor', 'middle')
        .attr('fill', C.text)
        .attr('font-size', '9px')
        .attr('font-weight', '600')
        .text(intersection.count);
    })(bi, inter, bx);
  }

  // -- 2. Matrix Dots (middle) ---------------------------------------------
  var matrixGroup = this.svg.append('g')
    .attr('class', 'upset-matrix')
    .attr('transform', 'translate(' + matrixX + ',' + matrixY + ')');

  // Alternating row backgrounds
  for (var ri = 0; ri < numRows; ri++) {
    matrixGroup.append('rect')
      .attr('x', -L.setSizeBarWidth - 10)
      .attr('y', ri * L.dotRowHeight)
      .attr('width', matrixWidth + L.setSizeBarWidth + 10)
      .attr('height', L.dotRowHeight)
      .attr('fill', ri % 2 === 0 ? C.rowEven : C.rowOdd);
  }

  // For each column (intersection), draw dots and connectors
  for (var ci = 0; ci < intersections.length; ci++) {
    var colInter = intersections[ci];
    var cx = ci * colWidth + L.gap / 2 + L.barWidth / 2;
    var memberSet = {};
    for (var mi = 0; mi < colInter.members.length; mi++) {
      memberSet[colInter.members[mi]] = true;
    }

    // Find min and max row indices for connector line
    var minRow = numRows;
    var maxRow = -1;
    var activeDots = [];

    for (var ei = 0; ei < entities.length; ei++) {
      var eUid = entities[ei].uid;
      var cy = ei * L.dotRowHeight + L.dotRowHeight / 2;

      if (memberSet[eUid]) {
        // Active dot
        var dotNode = entities[ei].node;
        var dotColor = dotNode ? (C[dotNode.type] || C.bar) : C.bar;

        matrixGroup.append('circle')
          .attr('cx', cx)
          .attr('cy', cy)
          .attr('r', L.dotRadius)
          .attr('fill', dotColor)
          .attr('class', 'upset-dot upset-dot-col-' + ci + ' upset-dot-row-' + ei);

        activeDots.push({ row: ei, cy: cy });
        if (ei < minRow) minRow = ei;
        if (ei > maxRow) maxRow = ei;
      } else {
        // Empty dot
        matrixGroup.append('circle')
          .attr('cx', cx)
          .attr('cy', cy)
          .attr('r', L.dotRadius - 1.5)
          .attr('fill', C.dotEmpty)
          .attr('class', 'upset-dot upset-dot-col-' + ci + ' upset-dot-row-' + ei);
      }
    }

    // Connector line between active dots (multi-entity intersections)
    if (activeDots.length > 1) {
      var lineY1 = activeDots[0].cy;
      var lineY2 = activeDots[activeDots.length - 1].cy;
      matrixGroup.append('line')
        .attr('x1', cx)
        .attr('y1', lineY1)
        .attr('x2', cx)
        .attr('y2', lineY2)
        .attr('stroke', C.connector)
        .attr('stroke-width', 2)
        .attr('class', 'upset-connector upset-connector-col-' + ci);
    }
  }

  // -- 3. Set Size Bar Chart (left) ----------------------------------------
  var setSizeGroup = this.svg.append('g')
    .attr('class', 'upset-set-sizes')
    .attr('transform', 'translate(' + L.margin.left + ',' + matrixY + ')');

  // Axis label
  setSizeGroup.append('text')
    .attr('x', L.setSizeBarWidth / 2)
    .attr('y', -6)
    .attr('text-anchor', 'middle')
    .attr('fill', C.textSecondary)
    .attr('font-size', '10px')
    .text('Set Size');

  for (var si = 0; si < entities.length; si++) {
    var entity = entities[si];
    var barY = si * L.dotRowHeight + 2;
    var barW = xSetScale(entity.freq);
    var setBarHeight = L.dotRowHeight - 4;

    setSizeGroup.append('rect')
      .attr('x', L.setSizeBarWidth - barW)
      .attr('y', barY)
      .attr('width', barW)
      .attr('height', setBarHeight)
      .attr('fill', C.barMuted)
      .attr('rx', 2);

    // Frequency label
    setSizeGroup.append('text')
      .attr('x', L.setSizeBarWidth - barW - 4)
      .attr('y', barY + setBarHeight / 2 + 3)
      .attr('text-anchor', 'end')
      .attr('fill', C.textMuted)
      .attr('font-size', '9px')
      .text(entity.freq);
  }

  // -- 4. Entity Name Labels (left of set size bars) -----------------------
  var labelGroup = this.svg.append('g')
    .attr('class', 'upset-labels')
    .attr('transform', 'translate(' + (L.margin.left - 6) + ',' + matrixY + ')');

  for (var li = 0; li < entities.length; li++) {
    var labelEntity = entities[li];
    var labelNode = labelEntity.node;
    var displayName = labelNode ? (labelNode.name || labelEntity.uid) : labelEntity.uid;

    // Truncate long names
    if (displayName.length > 20) {
      displayName = displayName.substring(0, 18) + '...';
    }

    var labelColor = labelNode ? (C[labelNode.type] || C.textSecondary) : C.textSecondary;

    (function (rowIdx, entityObj) {
      var label = labelGroup.append('text')
        .attr('x', 0)
        .attr('y', rowIdx * L.dotRowHeight + L.dotRowHeight / 2 + 3)
        .attr('text-anchor', 'end')
        .attr('fill', labelColor)
        .attr('font-size', '10px')
        .style('cursor', 'default');

      label.text(displayName);

      label.on('mouseover', function (event) {
        self._highlightRow(rowIdx, numCols, matrixX, matrixY, colWidth, L.dotRowHeight, matrixWidth);
        self._showEntityTooltip(event, entityObj, nodeById);
      });
      label.on('mouseout', function () {
        self._clearRowHighlight();
        self._hideTooltip();
      });
    })(li, labelEntity);
  }
};

// ---------------------------------------------------------------------------
// Tooltip helpers
// ---------------------------------------------------------------------------

/**
 * @private
 */
UpSetRenderer.prototype._showBarTooltip = function (event, intersection, nodeById) {
  var lines = [];
  lines.push('<strong>Intersection (' + intersection.count + ' changes)</strong>');
  for (var i = 0; i < intersection.members.length; i++) {
    var node = nodeById[intersection.members[i]];
    var name = node ? node.name : intersection.members[i];
    var type = node ? node.type : '?';
    lines.push('<span class="hg-tooltip-type">' + type + '</span> ' + name);
  }

  this._tooltip
    .html(lines.join('<br>'))
    .style('left', (event.pageX + 12) + 'px')
    .style('top', (event.pageY - 12) + 'px')
    .transition().duration(150).style('opacity', 1);
};

/**
 * @private
 */
UpSetRenderer.prototype._showEntityTooltip = function (event, entityObj, nodeById) {
  var node = entityObj.node;
  var lines = [];
  lines.push('<strong>' + (node ? node.name : entityObj.uid) + '</strong>');
  if (node) {
    lines.push('<span class="hg-tooltip-type">' + node.type + '</span>');
    if (node.className) lines.push('Class: ' + node.className);
  }
  lines.push('Appears in ' + entityObj.freq + ' changes');

  this._tooltip
    .html(lines.join('<br>'))
    .style('left', (event.pageX + 12) + 'px')
    .style('top', (event.pageY - 12) + 'px')
    .transition().duration(150).style('opacity', 1);
};

/**
 * @private
 */
UpSetRenderer.prototype._hideTooltip = function () {
  if (this._tooltip) {
    this._tooltip.transition().duration(200).style('opacity', 0);
  }
};

// ---------------------------------------------------------------------------
// Highlight helpers
// ---------------------------------------------------------------------------

/**
 * @private -- highlight an entire column (intersection)
 */
UpSetRenderer.prototype._highlightColumn = function (colIdx, numRows, matrixX, matrixY, colWidth, rowHeight) {
  if (!this.svg) return;
  // Remove previous highlight
  this.svg.selectAll('.upset-col-highlight').remove();

  var x = colIdx * colWidth;
  var height = numRows * rowHeight;

  this.svg.select('.upset-matrix').append('rect')
    .attr('class', 'upset-col-highlight')
    .attr('x', x)
    .attr('y', 0)
    .attr('width', colWidth)
    .attr('height', height)
    .attr('fill', 'rgba(79, 195, 247, 0.08)')
    .attr('pointer-events', 'none');
};

/**
 * @private
 */
UpSetRenderer.prototype._clearColumnHighlight = function () {
  if (!this.svg) return;
  this.svg.selectAll('.upset-col-highlight').remove();
};

/**
 * @private -- highlight an entire row (entity)
 */
UpSetRenderer.prototype._highlightRow = function (rowIdx, numCols, matrixX, matrixY, colWidth, rowHeight, matrixWidth) {
  if (!this.svg) return;
  this.svg.selectAll('.upset-row-highlight').remove();

  var y = rowIdx * rowHeight;

  this.svg.select('.upset-matrix').append('rect')
    .attr('class', 'upset-row-highlight')
    .attr('x', 0)
    .attr('y', y)
    .attr('width', matrixWidth)
    .attr('height', rowHeight)
    .attr('fill', 'rgba(79, 195, 247, 0.08)')
    .attr('pointer-events', 'none');
};

/**
 * @private
 */
UpSetRenderer.prototype._clearRowHighlight = function () {
  if (!this.svg) return;
  this.svg.selectAll('.upset-row-highlight').remove();
};

// ---------------------------------------------------------------------------
// Empty state
// ---------------------------------------------------------------------------

/**
 * @private -- render a message when there is nothing to display
 */
UpSetRenderer.prototype._renderEmpty = function (container) {
  var rect = container.node().getBoundingClientRect();
  var w = rect.width || 600;
  var h = rect.height || 400;

  this.svg = container.append('svg')
    .attr('class', 'upset-svg')
    .attr('width', '100%')
    .attr('height', '100%')
    .attr('viewBox', '0 0 ' + w + ' ' + h)
    .style('font-family', "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, sans-serif");

  this.svg.append('text')
    .attr('x', w / 2)
    .attr('y', h / 2)
    .attr('text-anchor', 'middle')
    .attr('fill', this._colors.textMuted)
    .attr('font-size', '14px')
    .text('No intersections to display.');

  this.svg.append('text')
    .attr('x', w / 2)
    .attr('y', h / 2 + 22)
    .attr('text-anchor', 'middle')
    .attr('fill', this._colors.textMuted)
    .attr('font-size', '11px')
    .text('Try adjusting filter type or minimum set size.');
};

/* ── BSMDiscovery ── */
/**
 * BSM Discovery Orchestrator
 *
 * Wires together ITILDataSimulator, HypergraphCore, BSMHypergraphRenderer,
 * and AnalyticsEngine.  Manages view state (original vs transposed), UI
 * controls, and analytics panel rendering.
 *
 * Usage:
 *   var app = new BSMDiscovery({ container: '#graph-container' });
 *   app.init();
 */

/* global ITILDataSimulator, HypergraphCore, BSMHypergraphRenderer, AnalyticsEngine, UpSetRenderer */

function BSMDiscovery(options) {
  options = options || {};
  this.containerSelector = options.container || '#graph-container';
  this.simulatorOptions = options.simulator || {};

  this._simulator = null;
  this._core = null;
  this._renderer = null;
  this._upsetRenderer = null;
  this._rawData = null;
  this._originalGraph = null;
  this._transposedGraph = null;
  this._isTransposed = false;
  this._isUpSetView = false;
  this._cooccurrenceFilter = '';

  // Analytics
  this._analytics = null;
  this._analyticsData = {};
  this._activeTab = 'centrality';
}

// ---------- Initialization ----------

/**
 * Field list for the single ServiceNow Table API query on task_ci.
 * Dot-walked fields pull data from both the change (task.*) and CI (ci_item.*).
 */
BSMDiscovery.QUERY_FIELDS = {
  task_ci: [
    'task.number', 'task.type', 'task.risk', 'task.impact',
    'task.u_impact_region', 'task.assignment_group', 'task.sys_created_on',
    'ci_item.name', 'ci_item.sys_class_name', 'ci_item.u_role',
    'ci_item.ip_address', 'ci_item.model_id', 'ci_item.sys_updated_on'
  ]
};

/**
 * Update the encoded query display to show the equivalent ServiceNow queries.
 */
BSMDiscovery.prototype._updateQueryDisplay = function () {
  var limitEl = document.getElementById('query-limit');
  var startEl = document.getElementById('query-start');
  var endEl = document.getElementById('query-end');
  var displayEl = document.getElementById('query-encoded');
  if (!limitEl || !startEl || !endEl || !displayEl) return;

  var limit = limitEl.value || 100;

  var queryParts = [];
  if (startEl.value) queryParts.push('task.sys_created_on>=' + startEl.value);
  if (endEl.value) queryParts.push('task.sys_created_on<=' + endEl.value);
  var query = queryParts.join('^');

  var fields = BSMDiscovery.QUERY_FIELDS.task_ci;
  var lines = [];
  lines.push('\u2500\u2500 task_ci \u2500\u2500');
  lines.push('sysparm_limit=' + limit);
  lines.push('sysparm_fields=' + fields.join(','));
  if (query) lines.push('sysparm_query=' + query);

  displayEl.textContent = lines.join('\n');
  displayEl.classList.add('visible');
};

/**
 * Re-initialize the app with new query parameters.
 * Reads values from the query parameter controls.
 */
BSMDiscovery.prototype.reInit = function () {
  var limitEl = document.getElementById('query-limit');
  var startEl = document.getElementById('query-start');
  var endEl = document.getElementById('query-end');

  var limit = limitEl ? parseInt(limitEl.value, 10) || 100 : 100;
  var startDate = startEl ? startEl.value : null;
  var endDate = endEl ? endEl.value : null;

  // Merge into simulator options — aligns with SNTableAPI parameters
  this.simulatorOptions.limit = limit;
  this.simulatorOptions.changeCount = Math.max(limit, this.simulatorOptions.changeCount || 200);
  if (startDate) this.simulatorOptions.startDate = startDate;
  if (endDate) this.simulatorOptions.endDate = endDate;

  this._updateQueryDisplay();
  this._isTransposed = false;
  this._isUpSetView = false;
  this.init();
};

BSMDiscovery.prototype.init = function () {
  var self = this;

  // Show loading
  this._setLoading(true, 'Generating ITIL data\u2026');

  // Use setTimeout to allow the loading UI to render
  setTimeout(function () {
    self._simulator = new ITILDataSimulator(self.simulatorOptions);
    self._core = new HypergraphCore();

    // Generate data
    self._setLoading(true, 'Building hypergraph\u2026');
    self._rawData = self._simulator.generate();
    self._originalGraph = self._core.build(self._rawData);
    self._transposedGraph = self._core.transpose(self._originalGraph);

    // Initialize renderer
    self._renderer = new BSMHypergraphRenderer(self.containerSelector, {
      onNodeClick: function (d) { self._showNodeDetail(d); },
      onStatsUpdate: function (stats, isTransposed) { self._updateStats(stats, isTransposed); }
    });

    // Render original view
    self._setLoading(true, 'Rendering visualization\u2026');
    setTimeout(function () {
      self._renderer.render(self._originalGraph);
      if (!self._controlsBound) {
        self._bindControls();
        self._controlsBound = true;
      }
      self._updateViewButtons();
      self._updateLegendCounts();
      self._updateCooccurrence();

      // --- Run analytics ---
      self._setLoading(true, 'Running analytics\u2026');
      setTimeout(function () {
        self._analytics = new AnalyticsEngine();

        var graph = self._originalGraph;
        var raw = self._rawData;

        // Compute ALL analytics
        var centralityResults = self._analytics.centrality(graph);
        var cascades = self._analytics.temporalCascades(graph, raw, 7);
        var velocity = self._analytics.changeVelocity(raw);
        var cooccurrence = self._analytics.weightedCooccurrence(graph, raw, 30);
        var anomalies = self._analytics.detectAnomalies(graph, raw);
        var riskHeatmap = self._analytics.riskHeatmap(graph, raw);
        var communities = self._analytics.detectCommunities(graph);
        var linkPredictions = self._analytics.linkPrediction(graph, 20);

        // Build incident array from rawData
        var incidents = [];
        if (raw && raw.incidents) {
          var incKeys = Object.keys(raw.incidents);
          for (var ii = 0; ii < incKeys.length; ii++) {
            incidents.push(raw.incidents[incKeys[ii]]);
          }
        }
        var incidentCorrelation = self._analytics.incidentCorrelation(incidents, graph);

        // Store results
        self._analyticsData = {
          centrality: centralityResults,
          cascades: cascades,
          velocity: velocity,
          cooccurrence: cooccurrence,
          anomalies: anomalies,
          riskHeatmap: riskHeatmap,
          communities: communities,
          linkPredictions: linkPredictions,
          incidentCorrelation: incidentCorrelation
        };

        // Supply centrality data to renderer
        self._renderer.setCentralityData(centralityResults.composite, 'composite');

        // Supply cluster data: build uid -> clusterId map
        var clusterMap = {};
        var comIds = Object.keys(communities.communities);
        for (var ci = 0; ci < comIds.length; ci++) {
          var members = communities.communities[comIds[ci]];
          for (var mi = 0; mi < members.length; mi++) {
            clusterMap[members[mi]] = parseInt(comIds[ci], 10);
          }
        }
        self._renderer.setClusterData(clusterMap);

        // Supply risk data: build uid -> score map
        var riskMap = {};
        for (var ri = 0; ri < riskHeatmap.length; ri++) {
          riskMap[riskHeatmap[ri].ci] = riskHeatmap[ri].riskScore;
        }
        self._renderer.setRiskData(riskMap);

        // Set anomaly nodes for CIs with riskScore > 70
        var anomalyUids = [];
        for (var ai = 0; ai < riskHeatmap.length; ai++) {
          if (riskHeatmap[ai].riskScore > 70) {
            anomalyUids.push(riskHeatmap[ai].ci);
          }
        }
        self._renderer.setAnomalyNodes(anomalyUids);

        // Populate all analytics panels
        self._renderCentralityPanel('composite');
        self._renderTemporalPanel();
        self._renderAnomaliesPanel();
        self._renderClustersPanel();
        self._renderImpactPanel();
        self._renderIncidentsPanel();

        // Bind analytics controls (only once)
        if (!self._analyticsControlsBound) {
          self._bindAnalyticsControls();
          self._analyticsControlsBound = true;
        }

        self._setLoading(false);
      }, 50);
    }, 50);
  }, 50);
};

// ---------- View Toggle ----------

BSMDiscovery.prototype.toggleTranspose = function () {
  this._isTransposed = !this._isTransposed;
  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  this._renderer.render(graph);
  this._updateViewButtons();
  this._updateLegendCounts();
  this._updateCooccurrence();
  this._hideNodeDetail();
};

BSMDiscovery.prototype.setView = function (transposed) {
  if (this._isTransposed === transposed) return;
  this._isTransposed = transposed;
  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  this._renderer.render(graph);
  this._updateViewButtons();
  this._updateLegendCounts();
  this._updateCooccurrence();
  this._hideNodeDetail();
};

// _updateViewButtons defined in UpSet View section below

// ---------- UI Binding ----------

BSMDiscovery.prototype._bindControls = function () {
  var self = this;

  // View toggle buttons
  var btnOriginal = document.getElementById('btn-original');
  var btnTransposed = document.getElementById('btn-transposed');
  var btnUpset = document.getElementById('btn-upset');
  if (btnOriginal) {
    btnOriginal.addEventListener('click', function () {
      self._exitUpSetView();
      self.setView(false);
      self._updateViewButtons();
    });
  }
  if (btnTransposed) {
    btnTransposed.addEventListener('click', function () {
      self._exitUpSetView();
      self.setView(true);
      self._updateViewButtons();
    });
  }
  if (btnUpset) {
    btnUpset.addEventListener('click', function () {
      self._toggleUpSetView();
    });
  }

  // Search
  var searchInput = document.getElementById('search-input');
  if (searchInput) {
    var debounceTimer;
    searchInput.addEventListener('input', function () {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(function () {
        self._renderer.setSearch(searchInput.value);
      }, 200);
    });
  }

  // Legend toggles
  var legendItems = document.querySelectorAll('.legend-item');
  legendItems.forEach(function (item) {
    item.addEventListener('click', function () {
      var type = item.getAttribute('data-type');
      self._renderer.toggleType(type);
      item.classList.toggle('hidden', !self._renderer.isTypeVisible(type));
    });
  });

  // Force sliders
  var chargeSlider = document.getElementById('charge-slider');
  var chargeValue = document.getElementById('charge-value');
  if (chargeSlider) {
    chargeSlider.addEventListener('input', function () {
      var val = parseInt(chargeSlider.value, 10);
      self._renderer.setChargeStrength(val);
      if (chargeValue) chargeValue.textContent = val;
    });
  }

  var linkSlider = document.getElementById('link-slider');
  var linkValue = document.getElementById('link-value');
  if (linkSlider) {
    linkSlider.addEventListener('input', function () {
      var val = parseInt(linkSlider.value, 10);
      self._renderer.setLinkDistance(val);
      if (linkValue) linkValue.textContent = val;
    });
  }

  // Co-occurrence filter buttons
  var coocBtns = document.querySelectorAll('.cooccurrence-type-btn');
  coocBtns.forEach(function (btn) {
    btn.addEventListener('click', function () {
      coocBtns.forEach(function (b) { b.classList.remove('active'); });
      btn.classList.add('active');
      self._cooccurrenceFilter = btn.getAttribute('data-filter') || '';
      self._updateCooccurrence();
    });
  });

  // Query parameter controls
  var queryApplyBtn = document.getElementById('query-apply');
  if (queryApplyBtn) {
    queryApplyBtn.addEventListener('click', function () {
      self.reInit();
    });
  }

  // Show initial encoded query
  this._updateQueryDisplay();

  // Click on graph background to clear highlight
  var container = document.querySelector(this.containerSelector);
  if (container) {
    container.addEventListener('click', function (e) {
      if (e.target.tagName === 'svg' || e.target.classList.contains('graph-layer')) {
        self._renderer.clearHighlight();
        self._hideNodeDetail();
      }
    });
  }

  // Window resize
  window.addEventListener('resize', function () {
    if (self._renderer) self._renderer.resize();
  });
};

// ---------- Analytics Controls Binding ----------

BSMDiscovery.prototype._bindAnalyticsControls = function () {
  var self = this;

  // Analytics panel toggle button
  var toggleBtn = document.getElementById('analytics-toggle');
  var analyticsPanel = document.getElementById('analytics-panel');
  if (toggleBtn && analyticsPanel) {
    toggleBtn.addEventListener('click', function () {
      var isOpen = analyticsPanel.classList.contains('open');
      if (isOpen) {
        analyticsPanel.classList.remove('open');
        toggleBtn.textContent = 'Analytics \u25B6';
      } else {
        analyticsPanel.classList.add('open');
        toggleBtn.textContent = 'Analytics \u25C0';
      }
    });
  }

  // Analytics collapse button
  var collapseBtn = document.getElementById('analytics-collapse');
  if (collapseBtn && analyticsPanel) {
    collapseBtn.addEventListener('click', function () {
      analyticsPanel.classList.remove('open');
      if (toggleBtn) toggleBtn.textContent = 'Analytics \u25B6';
    });
  }

  // Tab switching
  var tabBtns = document.querySelectorAll('.analytics-tab');
  var tabContents = document.querySelectorAll('.analytics-tab-content');
  tabBtns.forEach(function (btn) {
    btn.addEventListener('click', function () {
      var tabName = btn.getAttribute('data-tab');
      self._activeTab = tabName;

      // Update active tab button
      tabBtns.forEach(function (b) { b.classList.remove('active'); });
      btn.classList.add('active');

      // Show corresponding content
      tabContents.forEach(function (tc) { tc.classList.remove('active'); });
      var target = document.getElementById('tab-' + tabName);
      if (target) target.classList.add('active');

      // Update renderer viz mode based on tab
      self._renderer.clearAnalyticsOverlays();
      if (tabName === 'centrality') {
        self._renderer.setVizMode('centrality');
      } else if (tabName === 'clusters') {
        self._renderer.setVizMode('cluster');
      } else if (tabName === 'anomalies') {
        self._renderer.setVizMode('risk');
      } else {
        self._renderer.setVizMode('type');
      }
    });
  });

  // Metric toggle buttons
  var metricBtns = document.querySelectorAll('.metric-btn');
  metricBtns.forEach(function (btn) {
    btn.addEventListener('click', function () {
      var metric = btn.getAttribute('data-metric');
      metricBtns.forEach(function (b) { b.classList.remove('active'); });
      btn.classList.add('active');

      // Re-render centrality panel with selected metric
      self._renderCentralityPanel(metric);

      // Update renderer
      var centralityData = self._analyticsData.centrality;
      if (centralityData && centralityData[metric]) {
        self._renderer.setCentralityData(centralityData[metric], metric);
      }
    });
  });

  // Impact CI select
  var impactSelect = document.getElementById('impact-ci-select');
  if (impactSelect) {
    impactSelect.addEventListener('change', function () {
      var selectedUid = impactSelect.value;
      if (!selectedUid) {
        var resultsEl = document.getElementById('impact-results');
        if (resultsEl) resultsEl.innerHTML = '';
        self._renderer.clearAnalyticsOverlays();
        return;
      }
      var results = self._analytics.predictImpact(
        self._originalGraph,
        self._rawData,
        selectedUid
      );
      self._renderImpactResults(results, selectedUid);
    });
  }
};

// ---------- Stats Panel ----------

BSMDiscovery.prototype._updateStats = function (stats, isTransposed) {
  this._setText('stat-nodes', stats.totalNodes);
  this._setText('stat-edges', stats.totalEdges);
  this._setText('stat-density', stats.density);
  this._setText('stat-avg-degree', stats.avgDegree);
  this._setText('stat-max-degree', stats.maxDegree);
  this._setText('stat-avg-edge-size', stats.avgEdgeSize);

  // Update view indicator
  var viewLabel = document.getElementById('view-label');
  if (viewLabel) {
    viewLabel.textContent = isTransposed ? 'Transposed (H*)' : 'Original (H)';
  }

  // Update node/edge semantic labels
  var nodeLabel = document.getElementById('stat-nodes-label');
  var edgeLabel = document.getElementById('stat-edges-label');
  if (nodeLabel) {
    nodeLabel.textContent = isTransposed ? 'Change Nodes' : 'Entity Nodes';
  }
  if (edgeLabel) {
    edgeLabel.textContent = isTransposed ? 'Entity Hyperedges' : 'Change Hyperedges';
  }
};

// ---------- Legend Counts ----------

BSMDiscovery.prototype._updateLegendCounts = function () {
  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  var counts = {};
  for (var i = 0; i < graph.nodes.length; i++) {
    var t = graph.nodes[i].type;
    counts[t] = (counts[t] || 0) + 1;
  }
  // Also count edge types for transposed view
  for (var j = 0; j < graph.edges.length; j++) {
    var et = graph.edges[j].type;
    if (et) counts[et] = (counts[et] || 0) + 1;
  }

  var countEls = document.querySelectorAll('.legend-count');
  countEls.forEach(function (el) {
    var type = el.getAttribute('data-type');
    el.textContent = counts[type] || 0;
  });
};

// ---------- Node Detail Panel ----------

BSMDiscovery.prototype._showNodeDetail = function (d) {
  var panel = document.getElementById('node-detail');
  if (!panel) return;

  var nameEl = document.getElementById('detail-name');
  var badgeEl = document.getElementById('detail-badge');
  var bodyEl = document.getElementById('detail-body');

  if (nameEl) nameEl.textContent = d.name;
  if (badgeEl) {
    badgeEl.textContent = d.type;
    badgeEl.className = 'node-detail-badge ' + d.type;
  }

  var rows = [];
  var props = { uid: 'UID', className: 'Class', ipAddress: 'IP Address', model: 'Model', role: 'Role', risk: 'Risk', impact: 'Impact', changeType: 'Type', region: 'Region', assignmentGroup: 'Group', sysUpdatedOn: 'Updated', createdAt: 'Created' };
  var keys = Object.keys(props);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (d[key]) {
      rows.push('<div class="node-detail-row"><span class="detail-key">' + props[key] + '</span><span class="detail-val">' + d[key] + '</span></div>');
    }
  }

  // Degree
  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  if (graph.incidence[d.uid]) {
    rows.push('<div class="node-detail-row"><span class="detail-key">Degree</span><span class="detail-val">' + graph.incidence[d.uid].size + '</span></div>');
  }

  // Analytics info if available
  if (this._analyticsData.centrality && this._analyticsData.centrality.composite[d.uid] !== undefined) {
    var score = this._analyticsData.centrality.composite[d.uid];
    rows.push('<div class="node-detail-row"><span class="detail-key">Centrality</span><span class="detail-val">' + (Math.round(score * 10000) / 10000) + '</span></div>');
  }

  if (bodyEl) bodyEl.innerHTML = rows.join('');
  panel.classList.add('visible');
};

BSMDiscovery.prototype._hideNodeDetail = function () {
  var panel = document.getElementById('node-detail');
  if (panel) panel.classList.remove('visible');
};

// ---------- Co-occurrence Panel ----------

BSMDiscovery.prototype._updateCooccurrence = function () {
  var body = document.getElementById('cooccurrence-body');
  if (!body) return;

  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  var filter = this._cooccurrenceFilter || null;
  var pairs = this._core.cooccurrence(graph, filter, 15);

  if (pairs.length === 0) {
    body.innerHTML = '<div class="cooccurrence-empty">No co-occurring pairs found</div>';
    return;
  }

  var maxCount = pairs[0].count;

  // Build node name lookup from current graph
  var nameMap = {};
  for (var n = 0; n < graph.nodes.length; n++) {
    nameMap[graph.nodes[n].uid] = graph.nodes[n].name;
  }
  // Also check edges (in transposed view, original nodes become edges)
  for (var e = 0; e < graph.edges.length; e++) {
    if (graph.edges[e].name) nameMap[graph.edges[e].uid] = graph.edges[e].name;
  }

  var html = '<table class="cooccurrence-table">';
  html += '<tr><th>Pair</th><th></th><th>Shared</th></tr>';

  var self = this;
  for (var i = 0; i < pairs.length; i++) {
    var p = pairs[i];
    var nameA = nameMap[p.a] || p.a.split(':').pop().substring(0, 12);
    var nameB = nameMap[p.b] || p.b.split(':').pop().substring(0, 12);
    var barWidth = Math.round((p.count / maxCount) * 100);

    html += '<tr class="cooccurrence-row" data-idx="' + i + '">';
    html += '<td><div class="cooccurrence-pair">';
    html += '<span class="pair-name" title="' + nameA + '">' + nameA + '</span>';
    html += '<span class="pair-name" title="' + nameB + '">' + nameB + '</span>';
    html += '</div></td>';
    html += '<td class="cooccurrence-bar-cell"><div class="cooccurrence-bar" style="width:' + barWidth + '%"></div></td>';
    html += '<td class="cooccurrence-count">' + p.count + '</td>';
    html += '</tr>';
  }
  html += '</table>';
  body.innerHTML = html;

  // Bind click handlers on rows
  var rows = body.querySelectorAll('.cooccurrence-row');
  rows.forEach(function (row) {
    row.addEventListener('click', function () {
      var idx = parseInt(row.getAttribute('data-idx'), 10);
      var pair = pairs[idx];
      // Toggle active state
      var wasActive = row.classList.contains('active');
      rows.forEach(function (r) { r.classList.remove('active'); });
      if (wasActive) {
        self._renderer.clearHighlight();
      } else {
        row.classList.add('active');
        self._highlightPair(pair);
      }
    });
  });
};

BSMDiscovery.prototype._highlightPair = function (pair) {
  // Highlight both nodes and their shared change hyperedges in the graph
  var connectedSet = new Set();
  connectedSet.add(pair.a);
  connectedSet.add(pair.b);
  for (var i = 0; i < pair.sharedEdges.length; i++) {
    connectedSet.add(pair.sharedEdges[i]);
  }

  // Use the renderer's internal layers for highlighting
  var renderer = this._renderer;
  renderer._nodeLayer.selectAll('circle')
    .attr('opacity', function (n) { return connectedSet.has(n.uid) ? 1 : 0.1; })
    .attr('filter', function (n) { return n.uid === pair.a || n.uid === pair.b ? 'url(#glow)' : null; });

  renderer._labelLayer.selectAll('text')
    .attr('opacity', function (n) { return connectedSet.has(n.uid) ? 1 : 0.05; });

  renderer._linkLayer.selectAll('line')
    .attr('stroke-opacity', function (l) {
      var sUid = l.source.uid || l.source;
      var tUid = l.target.uid || l.target;
      return connectedSet.has(sUid) && connectedSet.has(tUid) ? 0.5 : 0.02;
    });
};

// ---------- Helper: Name Map ----------

BSMDiscovery.prototype._buildNameMap = function (graph) {
  var map = {};
  var i;
  for (i = 0; i < graph.nodes.length; i++) {
    map[graph.nodes[i].uid] = graph.nodes[i].name;
  }
  for (i = 0; i < graph.edges.length; i++) {
    if (graph.edges[i].name) {
      map[graph.edges[i].uid] = graph.edges[i].name;
    }
  }
  return map;
};

// ---------- Helper: Type Badge ----------

BSMDiscovery.prototype._typeBadge = function (uid) {
  var type = 'ci';
  if (uid.indexOf('group:') === 0) {
    type = 'group';
  } else if (uid.indexOf('service:') === 0) {
    type = 'service';
  }
  return '<span class="type-badge ' + type + '">' + type + '</span>';
};

// ---------- Helper: Node type from UID ----------

BSMDiscovery.prototype._nodeType = function (uid) {
  if (uid.indexOf('group:') === 0) return 'group';
  if (uid.indexOf('service:') === 0) return 'service';
  return 'ci';
};

// ==========================================================================
//  Panel Rendering Methods
// ==========================================================================

// ---------- Centrality Panel ----------

BSMDiscovery.prototype._renderCentralityPanel = function (metric) {
  var container = document.getElementById('centrality-rankings');
  if (!container) return;

  var data = this._analyticsData.centrality;
  if (!data || !data[metric]) {
    container.innerHTML = '<div class="analytics-empty">No centrality data available</div>';
    return;
  }

  var scores = data[metric];
  var nameMap = this._buildNameMap(this._originalGraph);
  var self = this;

  // Build sorted array
  var entries = [];
  var keys = Object.keys(scores);
  for (var i = 0; i < keys.length; i++) {
    entries.push({
      uid: keys[i],
      name: nameMap[keys[i]] || keys[i],
      score: scores[keys[i]],
      type: self._nodeType(keys[i])
    });
  }
  entries.sort(function (a, b) { return b.score - a.score; });
  entries = entries.slice(0, 15);

  if (entries.length === 0) {
    container.innerHTML = '<div class="analytics-empty">No nodes found</div>';
    return;
  }

  var html = '';
  for (var j = 0; j < entries.length; j++) {
    var e = entries[j];
    var pct = Math.round(e.score * 100);
    html += '<div class="ranking-item" data-uid="' + e.uid + '">';
    html += '<span class="ranking-rank">' + (j + 1) + '</span>';
    html += '<div class="ranking-info">';
    html += '<div class="ranking-name">' + e.name + '</div>';
    html += '<div class="ranking-detail">' + this._typeBadge(e.uid) + '</div>';
    html += '</div>';
    html += '<div class="ranking-score">' + (Math.round(e.score * 10000) / 10000) + '</div>';
    html += '<div class="ranking-bar"><div class="ranking-bar-fill" style="width:' + pct + '%"></div></div>';
    html += '</div>';
  }
  container.innerHTML = html;

  // Click handlers on ranking items
  var items = container.querySelectorAll('.ranking-item');
  items.forEach(function (item) {
    item.addEventListener('click', function () {
      var uid = item.getAttribute('data-uid');
      items.forEach(function (it) { it.classList.remove('active'); });
      item.classList.add('active');
      self._renderer.highlightNodes([uid]);
    });
  });
};

// ---------- Temporal Panel ----------

BSMDiscovery.prototype._renderTemporalPanel = function () {
  var self = this;
  var nameMap = this._buildNameMap(this._originalGraph);

  // Cascades
  var cascadeContainer = document.getElementById('cascade-list');
  if (cascadeContainer) {
    var cascades = this._analyticsData.cascades;
    if (!cascades || cascades.length === 0) {
      cascadeContainer.innerHTML = '<div class="analytics-empty">No temporal cascades detected</div>';
    } else {
      var cHtml = '';
      var maxCount = cascades[0].count;
      for (var i = 0; i < Math.min(cascades.length, 15); i++) {
        var c = cascades[i];
        var srcName = nameMap[c.source] || c.source;
        var tgtName = nameMap[c.target] || c.target;
        cHtml += '<div class="cascade-item" data-idx="' + i + '">';
        cHtml += '<span class="cascade-source">' + srcName + '</span>';
        cHtml += '<span class="cascade-arrow">\u2192</span>';
        cHtml += '<span class="cascade-target">' + tgtName + '</span>';
        cHtml += '<span class="cascade-count">' + c.count + ' (' + c.avgLagDays + 'd avg)</span>';
        cHtml += '</div>';
      }
      cascadeContainer.innerHTML = cHtml;

      // Click handlers for cascade items
      var cascadeItems = cascadeContainer.querySelectorAll('.cascade-item');
      cascadeItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var idx = parseInt(item.getAttribute('data-idx'), 10);
          var cascade = cascades[idx];
          cascadeItems.forEach(function (ci) { ci.classList.remove('active'); });
          item.classList.add('active');
          self._renderer.setCascadeOverlays([{
            source: cascade.source,
            target: cascade.target,
            count: cascade.count
          }]);
          self._renderer.highlightNodes([cascade.source, cascade.target]);
        });
      });
    }
  }

  // Velocity
  var velocityContainer = document.getElementById('velocity-list');
  if (velocityContainer) {
    var velocity = this._analyticsData.velocity;
    if (!velocity || Object.keys(velocity).length === 0) {
      velocityContainer.innerHTML = '<div class="analytics-empty">No velocity data available</div>';
    } else {
      var vEntries = [];
      var vKeys = Object.keys(velocity);
      for (var v = 0; v < vKeys.length; v++) {
        vEntries.push({
          uid: vKeys[v],
          name: nameMap[vKeys[v]] || vKeys[v],
          data: velocity[vKeys[v]]
        });
      }
      // Sort by avg descending
      vEntries.sort(function (a, b) { return b.data.avg - a.data.avg; });
      vEntries = vEntries.slice(0, 15);

      var vHtml = '';
      for (var vi = 0; vi < vEntries.length; vi++) {
        var ve = vEntries[vi];
        var trendClass = 'trend-stable';
        var trendIcon = '\u2194';
        if (ve.data.trend === 'increasing') {
          trendClass = 'trend-up';
          trendIcon = '\u2191';
        } else if (ve.data.trend === 'decreasing') {
          trendClass = 'trend-down';
          trendIcon = '\u2193';
        }
        vHtml += '<div class="ranking-item" data-uid="' + ve.uid + '">';
        vHtml += '<div class="ranking-info">';
        vHtml += '<div class="ranking-name">' + ve.name + '</div>';
        vHtml += '<div class="ranking-detail">avg ' + ve.data.avg + '/wk, max ' + ve.data.max + '/wk</div>';
        vHtml += '</div>';
        vHtml += '<span class="' + trendClass + '">' + trendIcon + ' ' + ve.data.trend + '</span>';
        vHtml += '</div>';
      }
      velocityContainer.innerHTML = vHtml;

      // Click handlers for velocity items
      var velItems = velocityContainer.querySelectorAll('.ranking-item');
      velItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var uid = item.getAttribute('data-uid');
          self._renderer.highlightNodes([uid]);
        });
      });
    }
  }
};

// ---------- Anomalies Panel ----------

BSMDiscovery.prototype._renderAnomaliesPanel = function () {
  var self = this;
  var nameMap = this._buildNameMap(this._originalGraph);

  // Risk Heatmap
  var riskContainer = document.getElementById('risk-heatmap');
  if (riskContainer) {
    var riskData = this._analyticsData.riskHeatmap;
    if (!riskData || riskData.length === 0) {
      riskContainer.innerHTML = '<div class="analytics-empty">No risk data available</div>';
    } else {
      var rHtml = '';
      var topRisk = riskData.slice(0, 15);
      for (var r = 0; r < topRisk.length; r++) {
        var ri = topRisk[r];
        var riskColor = ri.riskScore > 70 ? '#ff8a80' : (ri.riskScore > 40 ? '#ffb74d' : '#81c784');
        rHtml += '<div class="risk-item" data-uid="' + ri.ci + '">';
        rHtml += '<div class="ranking-info">';
        rHtml += '<div class="ranking-name">' + ri.name + '</div>';
        rHtml += '<div class="ranking-detail">';
        rHtml += 'Changes: ' + ri.factors.changeFrequency;
        rHtml += ' | Emergency: ' + (Math.round(ri.factors.emergencyRatio * 100)) + '%';
        rHtml += ' | Incidents: ' + ri.factors.incidentRate;
        rHtml += ' | Coupling: ' + ri.factors.couplingDensity;
        rHtml += '</div>';
        rHtml += '</div>';
        rHtml += '<div class="risk-score" style="color:' + riskColor + '">' + ri.riskScore + '</div>';
        rHtml += '<div class="risk-bar"><div class="risk-bar-fill" style="width:' + ri.riskScore + '%;background:' + riskColor + '"></div></div>';
        rHtml += '</div>';
      }
      riskContainer.innerHTML = rHtml;

      // Click handlers
      var riskItems = riskContainer.querySelectorAll('.risk-item');
      riskItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var uid = item.getAttribute('data-uid');
          riskItems.forEach(function (ri) { ri.classList.remove('active'); });
          item.classList.add('active');
          self._renderer.highlightNodes([uid]);
        });
      });
    }
  }

  // Unexpected Pairs
  var unexpectedContainer = document.getElementById('unexpected-pairs');
  if (unexpectedContainer) {
    var anomalies = this._analyticsData.anomalies;
    var unexpected = anomalies ? anomalies.unexpectedPairs : [];
    if (!unexpected || unexpected.length === 0) {
      unexpectedContainer.innerHTML = '<div class="analytics-empty">No unexpected pairs detected</div>';
    } else {
      var uHtml = '';
      for (var u = 0; u < Math.min(unexpected.length, 10); u++) {
        var up = unexpected[u];
        var severityClass = up.ratio > 5 ? 'danger' : 'warning';
        uHtml += '<div class="anomaly-alert ' + severityClass + '" data-a="' + up.a + '" data-b="' + up.b + '">';
        uHtml += '<div class="ranking-name">' + up.nameA + ' \u2194 ' + up.nameB + '</div>';
        uHtml += '<div class="ranking-detail">';
        uHtml += up.classA + ' \u00D7 ' + up.classB;
        uHtml += ' | actual: ' + up.actual + ', expected: ' + up.expected;
        uHtml += ' | ratio: ' + up.ratio + 'x';
        uHtml += '</div>';
        uHtml += '</div>';
      }
      unexpectedContainer.innerHTML = uHtml;

      // Click handlers
      var unexpItems = unexpectedContainer.querySelectorAll('.anomaly-alert');
      unexpItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var a = item.getAttribute('data-a');
          var b = item.getAttribute('data-b');
          self._renderer.highlightNodes([a, b]);
        });
      });
    }
  }

  // Orphan CIs
  var orphanContainer = document.getElementById('orphan-list');
  if (orphanContainer) {
    var orphans = (this._analyticsData.anomalies && this._analyticsData.anomalies.orphans) ? this._analyticsData.anomalies.orphans : [];
    if (orphans.length === 0) {
      orphanContainer.innerHTML = '<div class="analytics-empty">No orphan CIs detected</div>';
    } else {
      var oHtml = '';
      for (var o = 0; o < Math.min(orphans.length, 15); o++) {
        var orph = orphans[o];
        oHtml += '<div class="anomaly-alert warning" data-uid="' + orph.uid + '">';
        oHtml += '<div class="ranking-name">' + orph.name + '</div>';
        oHtml += '<div class="ranking-detail">Degree: ' + orph.degree + ' \u2014 ' + orph.reason + '</div>';
        oHtml += '</div>';
      }
      orphanContainer.innerHTML = oHtml;

      // Click handlers
      var orphanItems = orphanContainer.querySelectorAll('.anomaly-alert');
      orphanItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var uid = item.getAttribute('data-uid');
          self._renderer.highlightNodes([uid]);
        });
      });
    }
  }

  // Over-Coupled Pairs
  var overcoupledContainer = document.getElementById('overcoupled-list');
  if (overcoupledContainer) {
    var overCoupled = (this._analyticsData.anomalies && this._analyticsData.anomalies.overCoupled) ? this._analyticsData.anomalies.overCoupled : [];
    if (overCoupled.length === 0) {
      overcoupledContainer.innerHTML = '<div class="analytics-empty">No over-coupled pairs detected</div>';
    } else {
      var ocHtml = '';
      for (var oc = 0; oc < Math.min(overCoupled.length, 10); oc++) {
        var ocp = overCoupled[oc];
        ocHtml += '<div class="anomaly-alert danger" data-a="' + ocp.a + '" data-b="' + ocp.b + '">';
        ocHtml += '<div class="ranking-name">' + ocp.nameA + ' \u2194 ' + ocp.nameB + '</div>';
        ocHtml += '<div class="ranking-detail">';
        ocHtml += 'Jaccard: ' + ocp.jaccard + ' | Shared changes: ' + ocp.sharedChanges;
        ocHtml += '</div>';
        ocHtml += '</div>';
      }
      overcoupledContainer.innerHTML = ocHtml;

      // Click handlers
      var ocItems = overcoupledContainer.querySelectorAll('.anomaly-alert');
      ocItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var a = item.getAttribute('data-a');
          var b = item.getAttribute('data-b');
          self._renderer.highlightNodes([a, b]);
        });
      });
    }
  }
};

// ---------- Clusters Panel ----------

BSMDiscovery.prototype._renderClustersPanel = function () {
  var self = this;
  var nameMap = this._buildNameMap(this._originalGraph);
  var communities = this._analyticsData.communities;

  // Summary
  var summaryContainer = document.getElementById('cluster-summary');
  if (summaryContainer) {
    if (!communities || !communities.summary || communities.summary.length === 0) {
      summaryContainer.innerHTML = '<div class="analytics-empty">No communities detected</div>';
    } else {
      var sHtml = '';
      sHtml += '<div class="cluster-stat">Communities detected: <strong>' + communities.summary.length + '</strong></div>';
      sHtml += '<div class="cluster-stat">Modularity: <strong>' + communities.modularity + '</strong></div>';
      summaryContainer.innerHTML = sHtml;
    }
  }

  // Cluster Details
  var detailsContainer = document.getElementById('cluster-details');
  if (detailsContainer) {
    if (!communities || !communities.communities || Object.keys(communities.communities).length === 0) {
      detailsContainer.innerHTML = '<div class="analytics-empty">No cluster details available</div>';
    } else {
      var comIds = Object.keys(communities.communities);
      // Build summary lookup
      var summaryLookup = {};
      if (communities.summary) {
        for (var si = 0; si < communities.summary.length; si++) {
          summaryLookup[communities.summary[si].id] = communities.summary[si];
        }
      }

      var clusterPalette = [
        '#4fc3f7', '#ff8a65', '#81c784', '#ce93d8',
        '#ffd54f', '#4dd0e1', '#f48fb1', '#a5d6a7',
        '#90caf9', '#ffab91', '#80cbc4', '#e6ee9c'
      ];

      var dHtml = '';
      for (var ci = 0; ci < comIds.length; ci++) {
        var comId = comIds[ci];
        var members = communities.communities[comId];
        var summary = summaryLookup[comId] || {};
        var color = clusterPalette[ci % clusterPalette.length];

        dHtml += '<div class="cluster-card" data-cluster="' + comId + '" style="border-left: 3px solid ' + color + '">';
        dHtml += '<div class="cluster-header">';
        dHtml += '<strong>Cluster ' + comId + '</strong>';
        dHtml += '<span class="cluster-stat">' + members.length + ' members</span>';
        dHtml += '</div>';
        if (summary.dominantType) {
          dHtml += '<div class="ranking-detail">Type: ' + summary.dominantType + '</div>';
        }
        if (summary.dominantService) {
          dHtml += '<div class="ranking-detail">Service: ' + summary.dominantService + '</div>';
        }
        dHtml += '<div class="cluster-members" style="display:none;">';
        for (var mi = 0; mi < members.length; mi++) {
          var memberName = nameMap[members[mi]] || members[mi];
          dHtml += '<div class="cluster-member">' + self._typeBadge(members[mi]) + ' ' + memberName + '</div>';
        }
        dHtml += '</div>';
        dHtml += '</div>';
      }
      detailsContainer.innerHTML = dHtml;

      // Click handlers for cluster cards
      var clusterCards = detailsContainer.querySelectorAll('.cluster-card');
      clusterCards.forEach(function (card) {
        card.addEventListener('click', function () {
          var clusterId = card.getAttribute('data-cluster');

          // Toggle member list expansion
          var memberList = card.querySelector('.cluster-members');
          if (memberList) {
            var isHidden = memberList.style.display === 'none';
            memberList.style.display = isHidden ? 'block' : 'none';
          }

          // Highlight cluster members in graph
          var clusterMembers = communities.communities[clusterId] || [];
          self._renderer.setVizMode('cluster');
          self._renderer.highlightNodes(clusterMembers);
        });
      });
    }
  }
};

// ---------- Impact Panel ----------

BSMDiscovery.prototype._renderImpactPanel = function () {
  var self = this;
  var graph = this._originalGraph;
  var nameMap = this._buildNameMap(graph);

  // Populate CI select dropdown
  var selectEl = document.getElementById('impact-ci-select');
  if (selectEl) {
    // Clear existing options (except the default)
    var optHtml = '<option value="">Select a CI...</option>';
    var ciNodes = [];
    for (var i = 0; i < graph.nodes.length; i++) {
      if (graph.nodes[i].type === 'ci') {
        ciNodes.push(graph.nodes[i]);
      }
    }
    // Sort by name
    ciNodes.sort(function (a, b) {
      return a.name.localeCompare(b.name);
    });
    for (var j = 0; j < ciNodes.length; j++) {
      optHtml += '<option value="' + ciNodes[j].uid + '">' + ciNodes[j].name + '</option>';
    }
    selectEl.innerHTML = optHtml;
  }

  // Predicted Links
  var linksContainer = document.getElementById('predicted-links');
  if (linksContainer) {
    var predictions = this._analyticsData.linkPredictions;
    if (!predictions || predictions.length === 0) {
      linksContainer.innerHTML = '<div class="analytics-empty">No link predictions available</div>';
    } else {
      var maxScore = predictions[0].score;
      var lHtml = '';
      for (var li = 0; li < Math.min(predictions.length, 15); li++) {
        var lp = predictions[li];
        var barPct = maxScore > 0 ? Math.round((lp.score / maxScore) * 100) : 0;
        lHtml += '<div class="ranking-item" data-a="' + lp.a + '" data-b="' + lp.b + '">';
        lHtml += '<div class="ranking-info">';
        lHtml += '<div class="ranking-name">' + (lp.nameA || lp.aName || lp.a) + ' \u2194 ' + (lp.nameB || lp.bName || lp.b) + '</div>';
        lHtml += '<div class="ranking-detail">Adamic-Adar score: ' + lp.score + '</div>';
        lHtml += '</div>';
        lHtml += '<div class="ranking-bar"><div class="ranking-bar-fill" style="width:' + barPct + '%"></div></div>';
        lHtml += '</div>';
      }
      linksContainer.innerHTML = lHtml;

      // Click handlers
      var linkItems = linksContainer.querySelectorAll('.ranking-item');
      linkItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var a = item.getAttribute('data-a');
          var b = item.getAttribute('data-b');
          self._renderer.highlightNodes([a, b]);
        });
      });
    }
  }
};

// Impact Results (called when CI is selected)

BSMDiscovery.prototype._renderImpactResults = function (results, targetUid) {
  var self = this;
  var container = document.getElementById('impact-results');
  if (!container) return;

  if (!results || results.length === 0) {
    container.innerHTML = '<div class="analytics-empty">No impacted CIs predicted for this selection</div>';
    self._renderer.highlightNodes([targetUid]);
    return;
  }

  var html = '';
  var topResults = results.slice(0, 15);
  for (var i = 0; i < topResults.length; i++) {
    var r = topResults[i];
    var probPct = Math.round(r.probability * 100);
    html += '<div class="impact-item" data-uid="' + r.ci + '">';
    html += '<div class="ranking-info">';
    html += '<div class="ranking-name">' + r.name + '</div>';
    html += '<div class="impact-reason">' + r.reason + '</div>';
    html += '</div>';
    html += '<div class="impact-probability">' + probPct + '%</div>';
    html += '<div class="impact-bar"><div class="impact-bar-fill" style="width:' + probPct + '%"></div></div>';
    html += '</div>';
  }
  container.innerHTML = html;

  // Highlight the target + top impacted CIs
  var highlightUids = [targetUid];
  for (var j = 0; j < topResults.length; j++) {
    highlightUids.push(topResults[j].ci);
  }
  self._renderer.highlightNodes(highlightUids);

  // Click handlers for impact items
  var impactItems = container.querySelectorAll('.impact-item');
  impactItems.forEach(function (item) {
    item.addEventListener('click', function () {
      var uid = item.getAttribute('data-uid');
      impactItems.forEach(function (ii) { ii.classList.remove('active'); });
      item.classList.add('active');
      self._renderer.highlightNodes([targetUid, uid]);
    });
  });
};

// ---------- Incidents Panel ----------

BSMDiscovery.prototype._renderIncidentsPanel = function () {
  var self = this;
  var nameMap = this._buildNameMap(this._originalGraph);
  var incData = this._analyticsData.incidentCorrelation;

  // Fault Propagation
  var faultContainer = document.getElementById('fault-propagation');
  if (faultContainer) {
    var faults = incData ? incData.faultPropagation : [];
    if (!faults || faults.length === 0) {
      faultContainer.innerHTML = '<div class="analytics-empty">No fault propagation patterns detected</div>';
    } else {
      var fHtml = '';
      for (var fi = 0; fi < Math.min(faults.length, 15); fi++) {
        var fp = faults[fi];
        var srcName = nameMap[fp.source] || fp.source;
        var tgtName = nameMap[fp.target] || fp.target;
        fHtml += '<div class="incident-item" data-src="' + fp.source + '" data-tgt="' + fp.target + '">';
        fHtml += '<span class="cascade-source">' + srcName + '</span>';
        fHtml += '<span class="cascade-arrow">\u2192</span>';
        fHtml += '<span class="cascade-target">' + tgtName + '</span>';
        fHtml += '<span class="cascade-count">' + fp.count + ' events (' + fp.avgLagHours + 'h avg)</span>';
        fHtml += '</div>';
      }
      faultContainer.innerHTML = fHtml;

      // Click handlers
      var faultItems = faultContainer.querySelectorAll('.incident-item');
      faultItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var src = item.getAttribute('data-src');
          var tgt = item.getAttribute('data-tgt');
          self._renderer.highlightNodes([src, tgt]);
        });
      });
    }
  }

  // Incident Hotspots
  var hotspotsContainer = document.getElementById('incident-hotspots');
  if (hotspotsContainer) {
    var hotspots = incData ? incData.hotspots : [];
    if (!hotspots || hotspots.length === 0) {
      hotspotsContainer.innerHTML = '<div class="analytics-empty">No incident hotspots detected</div>';
    } else {
      var hHtml = '';
      var maxInc = hotspots[0].incidentCount;
      for (var hi = 0; hi < Math.min(hotspots.length, 15); hi++) {
        var hs = hotspots[hi];
        var barPct = maxInc > 0 ? Math.round((hs.incidentCount / maxInc) * 100) : 0;
        hHtml += '<div class="hotspot-item" data-uid="' + hs.ci + '">';
        hHtml += '<div class="ranking-info">';
        hHtml += '<div class="ranking-name">' + hs.name + '</div>';
        hHtml += '<div class="ranking-detail">';
        hHtml += 'Incidents: ' + hs.incidentCount;
        hHtml += ' | Avg Priority: ' + hs.avgPriority;
        if (hs.mtbf > 0) {
          hHtml += ' | MTBF: ' + hs.mtbf + 'h';
        }
        hHtml += '</div>';
        hHtml += '</div>';
        hHtml += '<div class="ranking-bar"><div class="ranking-bar-fill" style="width:' + barPct + '%"></div></div>';
        hHtml += '</div>';
      }
      hotspotsContainer.innerHTML = hHtml;

      // Click handlers
      var hsItems = hotspotsContainer.querySelectorAll('.hotspot-item');
      hsItems.forEach(function (item) {
        item.addEventListener('click', function () {
          var uid = item.getAttribute('data-uid');
          self._renderer.highlightNodes([uid]);
        });
      });
    }
  }

  // Service Fingerprints
  var fpContainer = document.getElementById('service-fingerprints');
  if (fpContainer) {
    var fingerprints = incData ? incData.serviceFingerprints : {};
    var fpKeys = Object.keys(fingerprints);
    if (fpKeys.length === 0) {
      fpContainer.innerHTML = '<div class="analytics-empty">No service fingerprints available</div>';
    } else {
      var fpHtml = '';
      for (var fpi = 0; fpi < fpKeys.length; fpi++) {
        var svcUid = fpKeys[fpi];
        var svcName = nameMap[svcUid] || svcUid;
        var sfp = fingerprints[svcUid];

        fpHtml += '<div class="fingerprint-card">';
        fpHtml += '<div class="cluster-header">';
        fpHtml += '<strong>' + svcName + '</strong>';
        fpHtml += '</div>';
        fpHtml += '<div class="ranking-detail">';
        fpHtml += 'Pattern: ' + sfp.pattern;
        fpHtml += ' | Affected CIs: ' + sfp.affectedCIs.length;
        fpHtml += ' | Avg Resolution: ' + sfp.avgResolutionHours + 'h';
        fpHtml += '</div>';

        // List affected CIs
        if (sfp.affectedCIs.length > 0) {
          fpHtml += '<div class="cluster-members">';
          for (var aci = 0; aci < sfp.affectedCIs.length; aci++) {
            var ciName = nameMap[sfp.affectedCIs[aci]] || sfp.affectedCIs[aci];
            fpHtml += '<div class="cluster-member">' + ciName + '</div>';
          }
          fpHtml += '</div>';
        }
        fpHtml += '</div>';
      }
      fpContainer.innerHTML = fpHtml;
    }
  }
};

// ---------- UpSet View ----------

BSMDiscovery.prototype._toggleUpSetView = function () {
  if (this._isUpSetView) {
    this._exitUpSetView();
  } else {
    this._enterUpSetView();
  }
};

BSMDiscovery.prototype._enterUpSetView = function () {
  this._isUpSetView = true;
  var self = this;

  // Stop force simulation and hide its SVG
  if (this._renderer) {
    if (this._renderer.simulation) {
      this._renderer.simulation.stop();
    }
    if (this._renderer.svg) {
      this._renderer.svg.style('display', 'none');
    }
  }

  // Initialize UpSet renderer if needed
  if (!this._upsetRenderer) {
    this._upsetRenderer = new UpSetRenderer(this.containerSelector, {
      onIntersectionClick: function (intersection) {
        // Highlight in analytics panel when available
        if (self._renderer) {
          self._renderer.highlightNodes(intersection.members);
        }
      }
    });
  }

  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  this._upsetRenderer.render(graph, {
    maxIntersections: 35,
    filterType: 'ci',
    topEntities: 15,
    minSetSize: 1
  });

  this._updateViewButtons();
  var viewLabel = document.getElementById('view-label');
  if (viewLabel) viewLabel.textContent = 'UpSet Intersections';
};

BSMDiscovery.prototype._exitUpSetView = function () {
  if (!this._isUpSetView) return;
  this._isUpSetView = false;

  // Destroy UpSet SVG
  if (this._upsetRenderer) {
    this._upsetRenderer.destroy();
  }

  // Show force graph SVG again
  if (this._renderer && this._renderer.svg) {
    this._renderer.svg.style('display', null);
  }

  // Re-render force graph
  var graph = this._isTransposed ? this._transposedGraph : this._originalGraph;
  this._renderer.render(graph);

  // Re-apply analytics overlays if present
  if (this._analyticsData.centrality) {
    var metric = this._activeTab === 'centrality' ? 'composite' : 'composite';
    this._renderer.setCentralityData(this._analyticsData.centrality[metric], metric);
  }

  this._updateViewButtons();
  this._updateLegendCounts();
};

BSMDiscovery.prototype._updateViewButtons = function () {
  var btnOrig = document.getElementById('btn-original');
  var btnTrans = document.getElementById('btn-transposed');
  var btnUpset = document.getElementById('btn-upset');

  if (btnOrig) btnOrig.classList.toggle('active', !this._isTransposed && !this._isUpSetView);
  if (btnTrans) btnTrans.classList.toggle('active', this._isTransposed && !this._isUpSetView);
  if (btnUpset) btnUpset.classList.toggle('active', this._isUpSetView);
};

// ---------- Loading ----------

BSMDiscovery.prototype._setLoading = function (show, message) {
  var overlay = document.getElementById('loading-overlay');
  var text = document.getElementById('loading-text');
  if (overlay) {
    overlay.classList.toggle('hidden', !show);
  }
  if (text && message) {
    text.textContent = message;
  }
};

// ---------- Helpers ----------

BSMDiscovery.prototype._setText = function (id, value) {
  var el = document.getElementById(id);
  if (el) el.textContent = value;
};

/* ── Init ── */
var app = new BSMDiscovery({
      container: '#graph-container',
      simulator: { changeCount: 200, incidentCount: 80, seed: 42, limit: 100 }
    });
    app.init();

    // Wire up detail close button
    document.getElementById('detail-close').addEventListener('click', function () {
      document.getElementById('node-detail').classList.remove('visible');
      app._renderer.clearHighlight();
    });
  </script>
</body>
</html>