<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Graph Test — 100 nodes</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0d1117; overflow: hidden; height: 100vh; }
    #graph { width: 100vw; height: 100vh; }
  </style>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    (function(){var k=['forceSimulation','forceLink','forceManyBody','forceCenter','forceCollide','forceX','forceY'];window.__d3F={};for(var i=0;i<k.length;i++)if(d3[k[i]])window.__d3F[k[i]]=d3[k[i]];})();
  </script>
  <script src="https://cdn.jsdelivr.net/npm/d3-force-webgpu@3.1.2/dist/d3-force-webgpu.min.js"></script>
  <script>
    (function(){var g=d3.forceSimulationGPU,a=d3.isWebGPUAvailable,c=d3.checkWebGPUSupport,o=window.__d3F;for(var k in o)if(o.hasOwnProperty(k))d3[k]=o[k];if(g)d3.forceSimulationGPU=g;if(a)d3.isWebGPUAvailable=a;if(c)d3.checkWebGPUSupport=c;delete window.__d3F;})();
  </script>
</head>
<body>
  <div id="graph"></div>
  <script>
    var W = window.innerWidth;
    var H = window.innerHeight;

    // ── 100 nodes ──
    var colors = { server: '#4fc3f7', network: '#ffb74d', storage: '#81c784', app: '#ce93d8' };
    var types = Object.keys(colors);
    var nodes = [];
    for (var i = 0; i < 100; i++) {
      nodes.push({
        id: 'n' + i,
        name: types[i % 4] + '-' + i,
        type: types[i % 4],
        x: W / 2 + (Math.random() - 0.5) * W * 0.6,
        y: H / 2 + (Math.random() - 0.5) * H * 0.6
      });
    }

    // ── ~170 links ──
    var links = [];
    var linkSet = new Set();
    var rng = function(seed) { return function() { seed=(seed+0x6d2b79f5)|0; var t=Math.imul(seed^seed>>>15,1|seed); t=(t+Math.imul(t^t>>>7,61|t))^t; return((t^t>>>14)>>>0)/4294967296; }; }(42);
    for (var e = 0; e < 200; e++) {
      var a = Math.floor(rng() * 100);
      var b = Math.floor(rng() * 100);
      if (a === b) continue;
      var key = Math.min(a,b) + '-' + Math.max(a,b);
      if (linkSet.has(key)) continue;
      linkSet.add(key);
      links.push({ source: 'n' + a, target: 'n' + b });
    }
    console.log('Data:', nodes.length, 'nodes,', links.length, 'links');
    console.log('Viewport:', W, 'x', H);

    // ── SVG ──
    var svg = d3.select('#graph').append('svg')
      .attr('width', W)
      .attr('height', H);
    var g = svg.append('g');

    svg.call(d3.zoom().scaleExtent([0.1, 8]).on('zoom', function(ev) {
      g.attr('transform', ev.transform);
    }));

    // ── Force simulation ──
    var useGPU = typeof d3.forceSimulationGPU === 'function';
    console.log('Engine:', useGPU ? 'WebGPU' : 'CPU');

    function buildSim(nodesArr, linksArr, gpu) {
      var fn = gpu ? d3.forceSimulationGPU : d3.forceSimulation;
      return fn(nodesArr)
        .force('link', d3.forceLink(linksArr).id(function(d){return d.id;}).distance(100).strength(0.1))
        .force('charge', d3.forceManyBody().strength(-400))
        .force('x', d3.forceX(W / 2).strength(0.05))
        .force('y', d3.forceY(H / 2).strength(0.05))
        .force('collision', d3.forceCollide(14));
    }

    var simulation = buildSim(nodes, links, useGPU);

    // ── Draw ──
    var linkSel = g.append('g').selectAll('line')
      .data(links).enter().append('line')
      .attr('stroke', '#444').attr('stroke-opacity', 0.2).attr('stroke-width', 0.5);

    var nodeSel = g.append('g').selectAll('circle')
      .data(nodes).enter().append('circle')
      .attr('r', 6)
      .attr('fill', function(d){return colors[d.type];})
      .attr('stroke', function(d){return d3.color(colors[d.type]).darker(0.6);})
      .attr('stroke-width', 1)
      .attr('cursor', 'grab')
      .call(d3.drag()
        .on('start', function(ev,d){ if(!ev.active) simulation.alphaTarget(0.3).restart(); d.fx=d.x; d.fy=d.y; })
        .on('drag', function(ev,d){ d.fx=ev.x; d.fy=ev.y; })
        .on('end', function(ev,d){ if(!ev.active) simulation.alphaTarget(0); d.fx=null; d.fy=null; }));

    var labelSel = g.append('g').selectAll('text')
      .data(nodes).enter().append('text')
      .text(function(d){return d.name;})
      .attr('text-anchor','middle').attr('dy',18)
      .attr('fill','#6e7681').attr('font-size','7px').attr('pointer-events','none');

    // ── GPU NaN guard ──
    var gpuTick = 0, gpuOK = false;
    simulation.on('tick', function() {
      if (useGPU && !gpuOK) {
        gpuTick++;
        var bad = false;
        for (var c = 0; c < Math.min(nodes.length, 5); c++) {
          if (isNaN(nodes[c].x) || isNaN(nodes[c].y)) { bad = true; break; }
        }
        if (bad) {
          console.warn('GPU NaN tick', gpuTick, '— CPU fallback');
          simulation.stop();
          nodes.forEach(function(n){ n.x=W/2+(Math.random()-0.5)*W*0.6; n.y=H/2+(Math.random()-0.5)*H*0.6; n.vx=0; n.vy=0; });
          simulation = buildSim(nodes, links, false);
          simulation.on('tick', tick);
          gpuOK = true;
          simulation.alpha(1).restart();
          return;
        }
        if (gpuTick >= 3) { gpuOK = true; console.log('WebGPU verified OK'); }
      }
      tick();
    });

    function tick() {
      linkSel
        .attr('x1',function(d){return d.source.x;}).attr('y1',function(d){return d.source.y;})
        .attr('x2',function(d){return d.target.x;}).attr('y2',function(d){return d.target.y;});
      nodeSel.attr('cx',function(d){return d.x;}).attr('cy',function(d){return d.y;});
      labelSel.attr('x',function(d){return d.x;}).attr('y',function(d){return d.y;});
    }
  </script>
</body>
</html>
